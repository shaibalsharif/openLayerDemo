{"ast":null,"code":"/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport { abstract } from '../util.js';\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\n\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n\n    this.ready = true;\n    /** @private */\n\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n\n    this.layer_ = layer;\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n\n    this.declutterExecutorGroup = null;\n  }\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n\n\n  getFeatures(pixel) {\n    return abstract();\n  }\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n\n\n  getData(pixel) {\n    return null;\n  }\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrame(frameState) {\n    return abstract();\n  }\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n\n\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  }\n  /**\n   * @return {LayerType} Layer.\n   */\n\n\n  getLayer() {\n    return this.layer_;\n  }\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n\n\n  handleFontsChanged() {}\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n\n\n  handleImageChange_(event) {\n    const image =\n    /** @type {import(\"../Image.js\").default} */\n    event.target;\n\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n\n\n  loadImage(image) {\n    let imageState = image.getState();\n\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n\n    return imageState == ImageState.LOADED;\n  }\n  /**\n   * @protected\n   */\n\n\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n\n}\n\nexport default LayerRenderer;","map":{"version":3,"names":["EventType","ImageState","Observable","abstract","LayerRenderer","constructor","layer","ready","boundHandleImageChange_","handleImageChange_","bind","layer_","declutterExecutorGroup","getFeatures","pixel","getData","prepareFrame","frameState","renderFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","undefined","createLoadedTileFinder","source","projection","tileRange","callback","forEachLoadedTile","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","getLayer","handleFontsChanged","event","image","getState","LOADED","renderIfReadyAndVisible","loadImage","imageState","ERROR","addEventListener","CHANGE","IDLE","load","getVisible","getSourceState","changed","disposeInternal"],"sources":["D:/Work/Learning/demo/node_modules/ol/renderer/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}