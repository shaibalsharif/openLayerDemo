{"ast":null,"code":"/**\n * @module ol/control/ZoomSlider\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport PointerEventType from '../pointer/EventType.js';\nimport { CLASS_CONTROL, CLASS_UNSELECTABLE } from '../css.js';\nimport { clamp } from '../math.js';\nimport { easeOut } from '../easing.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { stopPropagation } from '../events/Event.js';\n/**\n * The enum for available directions.\n *\n * @enum {number}\n */\n\nconst Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1\n};\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoomslider'] CSS class name.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n */\n\n/**\n * @classdesc\n * A slider type of control for zooming.\n *\n * Example:\n *\n *     map.addControl(new ZoomSlider());\n *\n * @api\n */\n\nclass ZoomSlider extends Control {\n  /**\n   * @param {Options} [options] Zoom slider options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super({\n      element: document.createElement('div'),\n      render: options.render\n    });\n    /**\n     * @type {!Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    this.dragListenerKeys_ = [];\n    /**\n     * Will hold the current resolution of the view.\n     *\n     * @type {number|undefined}\n     * @private\n     */\n\n    this.currentResolution_ = undefined;\n    /**\n     * The direction of the slider. Will be determined from actual display of the\n     * container and defaults to Direction.VERTICAL.\n     *\n     * @type {Direction}\n     * @private\n     */\n\n    this.direction_ = Direction.VERTICAL;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.dragging_;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.heightLimit_ = 0;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.widthLimit_ = 0;\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n\n    this.startX_;\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n\n    this.startY_;\n    /**\n     * The calculated thumb size (border box plus margins).  Set when initSlider_\n     * is called.\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n\n    this.thumbSize_ = null;\n    /**\n     * Whether the slider is initialized.\n     * @type {boolean}\n     * @private\n     */\n\n    this.sliderInitialized_ = false;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n    const className = options.className !== undefined ? options.className : 'ol-zoomslider';\n    const thumbElement = document.createElement('button');\n    thumbElement.setAttribute('type', 'button');\n    thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;\n    const containerElement = this.element;\n    containerElement.className = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n    containerElement.addEventListener(PointerEventType.POINTERDOWN, this.handleDraggerStart_.bind(this), false);\n    containerElement.addEventListener(PointerEventType.POINTERMOVE, this.handleDraggerDrag_.bind(this), false);\n    containerElement.addEventListener(PointerEventType.POINTERUP, this.handleDraggerEnd_.bind(this), false);\n    containerElement.addEventListener(EventType.CLICK, this.handleContainerClick_.bind(this), false);\n    thumbElement.addEventListener(EventType.CLICK, stopPropagation, false);\n  }\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n\n\n  setMap(map) {\n    super.setMap(map);\n\n    if (map) {\n      map.render();\n    }\n  }\n  /**\n   * Initializes the slider element. This will determine and set this controls\n   * direction_ and also constrain the dragging of the thumb to always be within\n   * the bounds of the container.\n   *\n   * @return {boolean} Initialization successful\n   * @private\n   */\n\n\n  initSlider_() {\n    const container = this.element;\n    let containerWidth = container.offsetWidth;\n    let containerHeight = container.offsetHeight;\n\n    if (containerWidth === 0 && containerHeight === 0) {\n      return this.sliderInitialized_ = false;\n    }\n\n    const containerStyle = getComputedStyle(container);\n    containerWidth -= parseFloat(containerStyle['paddingRight']) + parseFloat(containerStyle['paddingLeft']);\n    containerHeight -= parseFloat(containerStyle['paddingTop']) + parseFloat(containerStyle['paddingBottom']);\n    const thumb =\n    /** @type {HTMLElement} */\n    container.firstElementChild;\n    const thumbStyle = getComputedStyle(thumb);\n    const thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle['marginRight']) + parseFloat(thumbStyle['marginLeft']);\n    const thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle['marginTop']) + parseFloat(thumbStyle['marginBottom']);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n\n    if (containerWidth > containerHeight) {\n      this.direction_ = Direction.HORIZONTAL;\n      this.widthLimit_ = containerWidth - thumbWidth;\n    } else {\n      this.direction_ = Direction.VERTICAL;\n      this.heightLimit_ = containerHeight - thumbHeight;\n    }\n\n    return this.sliderInitialized_ = true;\n  }\n  /**\n   * @param {PointerEvent} event The browser event to handle.\n   * @private\n   */\n\n\n  handleContainerClick_(event) {\n    const view = this.getMap().getView();\n    const relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);\n    const resolution = this.getResolutionForPosition_(relativePosition);\n    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));\n    view.animateInternal({\n      zoom: zoom,\n      duration: this.duration_,\n      easing: easeOut\n    });\n  }\n  /**\n   * Handle dragger start events.\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n\n\n  handleDraggerStart_(event) {\n    if (!this.dragging_ && event.target === this.element.firstElementChild) {\n      const element =\n      /** @type {HTMLElement} */\n      this.element.firstElementChild;\n      this.getMap().getView().beginInteraction();\n      this.startX_ = event.clientX - parseFloat(element.style.left);\n      this.startY_ = event.clientY - parseFloat(element.style.top);\n      this.dragging_ = true;\n\n      if (this.dragListenerKeys_.length === 0) {\n        const drag = this.handleDraggerDrag_;\n        const end = this.handleDraggerEnd_;\n        const doc = this.getMap().getOwnerDocument();\n        this.dragListenerKeys_.push(listen(doc, PointerEventType.POINTERMOVE, drag, this), listen(doc, PointerEventType.POINTERUP, end, this));\n      }\n    }\n  }\n  /**\n   * Handle dragger drag events.\n   *\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n\n\n  handleDraggerDrag_(event) {\n    if (this.dragging_) {\n      const deltaX = event.clientX - this.startX_;\n      const deltaY = event.clientY - this.startY_;\n      const relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n    }\n  }\n  /**\n   * Handle dragger end events.\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n\n\n  handleDraggerEnd_(event) {\n    if (this.dragging_) {\n      const view = this.getMap().getView();\n      view.endInteraction();\n      this.dragging_ = false;\n      this.startX_ = undefined;\n      this.startY_ = undefined;\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n    }\n  }\n  /**\n   * Positions the thumb inside its container according to the given resolution.\n   *\n   * @param {number} res The res.\n   * @private\n   */\n\n\n  setThumbPosition_(res) {\n    const position = this.getPositionForResolution_(res);\n    const thumb =\n    /** @type {HTMLElement} */\n    this.element.firstElementChild;\n\n    if (this.direction_ == Direction.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position + 'px';\n    } else {\n      thumb.style.top = this.heightLimit_ * position + 'px';\n    }\n  }\n  /**\n   * Calculates the relative position of the thumb given x and y offsets.  The\n   * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n   * in pixel units within the dragger limits.\n   *\n   * @param {number} x Pixel position relative to the left of the slider.\n   * @param {number} y Pixel position relative to the top of the slider.\n   * @return {number} The relative position of the thumb.\n   * @private\n   */\n\n\n  getRelativePosition_(x, y) {\n    let amount;\n\n    if (this.direction_ === Direction.HORIZONTAL) {\n      amount = x / this.widthLimit_;\n    } else {\n      amount = y / this.heightLimit_;\n    }\n\n    return clamp(amount, 0, 1);\n  }\n  /**\n   * Calculates the corresponding resolution of the thumb given its relative\n   * position (where 0 is the minimum and 1 is the maximum).\n   *\n   * @param {number} position The relative position of the thumb.\n   * @return {number} The corresponding resolution.\n   * @private\n   */\n\n\n  getResolutionForPosition_(position) {\n    const fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position);\n  }\n  /**\n   * Determines the relative position of the slider for the given resolution.  A\n   * relative position of 0 corresponds to the minimum view resolution.  A\n   * relative position of 1 corresponds to the maximum view resolution.\n   *\n   * @param {number} res The resolution.\n   * @return {number} The relative position value (between 0 and 1).\n   * @private\n   */\n\n\n  getPositionForResolution_(res) {\n    const fn = this.getMap().getView().getValueForResolutionFunction();\n    return clamp(1 - fn(res), 0, 1);\n  }\n  /**\n   * Update the zoomslider element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n\n\n  render(mapEvent) {\n    if (!mapEvent.frameState) {\n      return;\n    }\n\n    if (!this.sliderInitialized_ && !this.initSlider_()) {\n      return;\n    }\n\n    const res = mapEvent.frameState.viewState.resolution;\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  }\n\n}\n\nexport default ZoomSlider;","map":{"version":3,"names":["Control","EventType","PointerEventType","CLASS_CONTROL","CLASS_UNSELECTABLE","clamp","easeOut","listen","unlistenByKey","stopPropagation","Direction","VERTICAL","HORIZONTAL","ZoomSlider","constructor","options","element","document","createElement","render","dragListenerKeys_","currentResolution_","undefined","direction_","dragging_","heightLimit_","widthLimit_","startX_","startY_","thumbSize_","sliderInitialized_","duration_","duration","className","thumbElement","setAttribute","containerElement","appendChild","addEventListener","POINTERDOWN","handleDraggerStart_","bind","POINTERMOVE","handleDraggerDrag_","POINTERUP","handleDraggerEnd_","CLICK","handleContainerClick_","setMap","map","initSlider_","container","containerWidth","offsetWidth","containerHeight","offsetHeight","containerStyle","getComputedStyle","parseFloat","thumb","firstElementChild","thumbStyle","thumbWidth","thumbHeight","event","view","getMap","getView","relativePosition","getRelativePosition_","offsetX","offsetY","resolution","getResolutionForPosition_","zoom","getConstrainedZoom","getZoomForResolution","animateInternal","easing","target","beginInteraction","clientX","style","left","clientY","top","length","drag","end","doc","getOwnerDocument","push","deltaX","deltaY","setResolution","endInteraction","forEach","setThumbPosition_","res","position","getPositionForResolution_","x","y","amount","fn","getResolutionForValueFunction","getValueForResolutionFunction","mapEvent","frameState","viewState"],"sources":["D:/Work/Learning/demo/node_modules/ol/control/ZoomSlider.js"],"sourcesContent":["/**\n * @module ol/control/ZoomSlider\n */\n\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport PointerEventType from '../pointer/EventType.js';\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\nimport {clamp} from '../math.js';\nimport {easeOut} from '../easing.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {stopPropagation} from '../events/Event.js';\n\n/**\n * The enum for available directions.\n *\n * @enum {number}\n */\nconst Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1,\n};\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoomslider'] CSS class name.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n */\n\n/**\n * @classdesc\n * A slider type of control for zooming.\n *\n * Example:\n *\n *     map.addControl(new ZoomSlider());\n *\n * @api\n */\nclass ZoomSlider extends Control {\n  /**\n   * @param {Options} [options] Zoom slider options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      render: options.render,\n    });\n\n    /**\n     * @type {!Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * Will hold the current resolution of the view.\n     *\n     * @type {number|undefined}\n     * @private\n     */\n    this.currentResolution_ = undefined;\n\n    /**\n     * The direction of the slider. Will be determined from actual display of the\n     * container and defaults to Direction.VERTICAL.\n     *\n     * @type {Direction}\n     * @private\n     */\n    this.direction_ = Direction.VERTICAL;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.heightLimit_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.widthLimit_ = 0;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.startX_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.startY_;\n\n    /**\n     * The calculated thumb size (border box plus margins).  Set when initSlider_\n     * is called.\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.thumbSize_ = null;\n\n    /**\n     * Whether the slider is initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.sliderInitialized_ = false;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-zoomslider';\n    const thumbElement = document.createElement('button');\n    thumbElement.setAttribute('type', 'button');\n    thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;\n    const containerElement = this.element;\n    containerElement.className =\n      className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n\n    containerElement.addEventListener(\n      PointerEventType.POINTERDOWN,\n      this.handleDraggerStart_.bind(this),\n      false\n    );\n    containerElement.addEventListener(\n      PointerEventType.POINTERMOVE,\n      this.handleDraggerDrag_.bind(this),\n      false\n    );\n    containerElement.addEventListener(\n      PointerEventType.POINTERUP,\n      this.handleDraggerEnd_.bind(this),\n      false\n    );\n\n    containerElement.addEventListener(\n      EventType.CLICK,\n      this.handleContainerClick_.bind(this),\n      false\n    );\n    thumbElement.addEventListener(EventType.CLICK, stopPropagation, false);\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      map.render();\n    }\n  }\n\n  /**\n   * Initializes the slider element. This will determine and set this controls\n   * direction_ and also constrain the dragging of the thumb to always be within\n   * the bounds of the container.\n   *\n   * @return {boolean} Initialization successful\n   * @private\n   */\n  initSlider_() {\n    const container = this.element;\n    let containerWidth = container.offsetWidth;\n    let containerHeight = container.offsetHeight;\n    if (containerWidth === 0 && containerHeight === 0) {\n      return (this.sliderInitialized_ = false);\n    }\n\n    const containerStyle = getComputedStyle(container);\n    containerWidth -=\n      parseFloat(containerStyle['paddingRight']) +\n      parseFloat(containerStyle['paddingLeft']);\n    containerHeight -=\n      parseFloat(containerStyle['paddingTop']) +\n      parseFloat(containerStyle['paddingBottom']);\n    const thumb = /** @type {HTMLElement} */ (container.firstElementChild);\n    const thumbStyle = getComputedStyle(thumb);\n    const thumbWidth =\n      thumb.offsetWidth +\n      parseFloat(thumbStyle['marginRight']) +\n      parseFloat(thumbStyle['marginLeft']);\n    const thumbHeight =\n      thumb.offsetHeight +\n      parseFloat(thumbStyle['marginTop']) +\n      parseFloat(thumbStyle['marginBottom']);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n\n    if (containerWidth > containerHeight) {\n      this.direction_ = Direction.HORIZONTAL;\n      this.widthLimit_ = containerWidth - thumbWidth;\n    } else {\n      this.direction_ = Direction.VERTICAL;\n      this.heightLimit_ = containerHeight - thumbHeight;\n    }\n    return (this.sliderInitialized_ = true);\n  }\n\n  /**\n   * @param {PointerEvent} event The browser event to handle.\n   * @private\n   */\n  handleContainerClick_(event) {\n    const view = this.getMap().getView();\n\n    const relativePosition = this.getRelativePosition_(\n      event.offsetX - this.thumbSize_[0] / 2,\n      event.offsetY - this.thumbSize_[1] / 2\n    );\n\n    const resolution = this.getResolutionForPosition_(relativePosition);\n    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));\n\n    view.animateInternal({\n      zoom: zoom,\n      duration: this.duration_,\n      easing: easeOut,\n    });\n  }\n\n  /**\n   * Handle dragger start events.\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerStart_(event) {\n    if (!this.dragging_ && event.target === this.element.firstElementChild) {\n      const element = /** @type {HTMLElement} */ (\n        this.element.firstElementChild\n      );\n      this.getMap().getView().beginInteraction();\n      this.startX_ = event.clientX - parseFloat(element.style.left);\n      this.startY_ = event.clientY - parseFloat(element.style.top);\n      this.dragging_ = true;\n\n      if (this.dragListenerKeys_.length === 0) {\n        const drag = this.handleDraggerDrag_;\n        const end = this.handleDraggerEnd_;\n        const doc = this.getMap().getOwnerDocument();\n        this.dragListenerKeys_.push(\n          listen(doc, PointerEventType.POINTERMOVE, drag, this),\n          listen(doc, PointerEventType.POINTERUP, end, this)\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle dragger drag events.\n   *\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerDrag_(event) {\n    if (this.dragging_) {\n      const deltaX = event.clientX - this.startX_;\n      const deltaY = event.clientY - this.startY_;\n      const relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ =\n        this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n    }\n  }\n\n  /**\n   * Handle dragger end events.\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerEnd_(event) {\n    if (this.dragging_) {\n      const view = this.getMap().getView();\n      view.endInteraction();\n\n      this.dragging_ = false;\n      this.startX_ = undefined;\n      this.startY_ = undefined;\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n    }\n  }\n\n  /**\n   * Positions the thumb inside its container according to the given resolution.\n   *\n   * @param {number} res The res.\n   * @private\n   */\n  setThumbPosition_(res) {\n    const position = this.getPositionForResolution_(res);\n    const thumb = /** @type {HTMLElement} */ (this.element.firstElementChild);\n\n    if (this.direction_ == Direction.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position + 'px';\n    } else {\n      thumb.style.top = this.heightLimit_ * position + 'px';\n    }\n  }\n\n  /**\n   * Calculates the relative position of the thumb given x and y offsets.  The\n   * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n   * in pixel units within the dragger limits.\n   *\n   * @param {number} x Pixel position relative to the left of the slider.\n   * @param {number} y Pixel position relative to the top of the slider.\n   * @return {number} The relative position of the thumb.\n   * @private\n   */\n  getRelativePosition_(x, y) {\n    let amount;\n    if (this.direction_ === Direction.HORIZONTAL) {\n      amount = x / this.widthLimit_;\n    } else {\n      amount = y / this.heightLimit_;\n    }\n    return clamp(amount, 0, 1);\n  }\n\n  /**\n   * Calculates the corresponding resolution of the thumb given its relative\n   * position (where 0 is the minimum and 1 is the maximum).\n   *\n   * @param {number} position The relative position of the thumb.\n   * @return {number} The corresponding resolution.\n   * @private\n   */\n  getResolutionForPosition_(position) {\n    const fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position);\n  }\n\n  /**\n   * Determines the relative position of the slider for the given resolution.  A\n   * relative position of 0 corresponds to the minimum view resolution.  A\n   * relative position of 1 corresponds to the maximum view resolution.\n   *\n   * @param {number} res The resolution.\n   * @return {number} The relative position value (between 0 and 1).\n   * @private\n   */\n  getPositionForResolution_(res) {\n    const fn = this.getMap().getView().getValueForResolutionFunction();\n    return clamp(1 - fn(res), 0, 1);\n  }\n\n  /**\n   * Update the zoomslider element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    if (!mapEvent.frameState) {\n      return;\n    }\n    if (!this.sliderInitialized_ && !this.initSlider_()) {\n      return;\n    }\n    const res = mapEvent.frameState.viewState.resolution;\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  }\n}\n\nexport default ZoomSlider;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}