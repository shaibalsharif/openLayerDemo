{"ast":null,"code":"/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { listenImage } from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n    /**\n     * @private\n     * @type {?string}\n     */\n\n    this.crossOrigin_ = crossOrigin;\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n\n    this.src_ = src;\n    this.key = src;\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n\n    this.image_ = new Image();\n\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n    /**\n     * @private\n     * @type {?function():void}\n     */\n\n\n    this.unlisten_ = null;\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n\n\n  getImage() {\n    return this.image_;\n  }\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n\n\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n\n\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n\n\n  handleImageLoad_() {\n    const image =\n    /** @type {HTMLImageElement} */\n    this.image_;\n\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n\n    this.unlistenImage_();\n    this.changed();\n  }\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n\n\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n    }\n  }\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n\n\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n\n}\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\n\n\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;","map":{"version":3,"names":["Tile","TileState","createCanvasContext2D","listenImage","ImageTile","constructor","tileCoord","state","src","crossOrigin","tileLoadFunction","options","crossOrigin_","src_","key","image_","Image","unlisten_","tileLoadFunction_","getImage","setImage","element","LOADED","unlistenImage_","changed","handleImageError_","ERROR","getBlankImage","handleImageLoad_","image","naturalWidth","naturalHeight","EMPTY","load","IDLE","LOADING","bind","ctx","fillStyle","fillRect","canvas"],"sources":["D:/Work/Learning/demo/node_modules/ol/ImageTile.js"],"sourcesContent":["/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}