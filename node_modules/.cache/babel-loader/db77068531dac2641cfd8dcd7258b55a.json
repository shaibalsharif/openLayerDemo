{"ast":null,"code":"/**\n * @module ol/MapBrowserEventHandler\n */\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { VOID } from './functions.js';\nimport { listen, unlistenByKey } from './events.js';\n\nclass MapBrowserEventHandler extends Target {\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n\n    this.map_ = map;\n    /**\n     * @type {any}\n     * @private\n     */\n\n    this.clickTimeoutId_;\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n\n    this.emulateClicks_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.dragging_ = false;\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n\n    this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n\n    this.down_ = null;\n    const element = this.map_.getViewport();\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n\n    this.activePointers_ = [];\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n\n    this.trackedTouches_ = {};\n    this.element_ = element;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n\n    this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n\n    this.originalPointerMoveEvent_;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n\n    this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, this.relayMoveEvent_, this);\n    /**\n     * @private\n     */\n\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n    this.element_.addEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(\n      /** @this {MapBrowserEventHandler} */\n      function () {\n        this.clickTimeoutId_ = undefined;\n        const newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  }\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n    const id = event.pointerId;\n\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[id];\n\n      for (const pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n      this.trackedTouches_[id] = event;\n    }\n\n    this.activePointers_ = Object.values(this.trackedTouches_);\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n\n    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n\n\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  handlePointerDown_(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent); // Store a copy of the down event\n\n    this.down_ =\n    /** @type {PointerEvent} */\n    {};\n\n    for (const property in pointerEvent) {\n      const value = pointerEvent[property];\n      this.down_[property] = typeof value === 'function' ? VOID : value;\n    }\n\n    if (this.dragListenerKeys_.length === 0) {\n      const doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n    }\n  }\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  relayMoveEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n  }\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n\n\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    const originalEvent = this.originalPointerMoveEvent_;\n\n    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n      event.preventDefault();\n    }\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n\n\n  isMoving_(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    super.disposeInternal();\n  }\n\n}\n\nexport default MapBrowserEventHandler;","map":{"version":3,"names":["EventType","MapBrowserEvent","MapBrowserEventType","PointerEventType","Target","PASSIVE_EVENT_LISTENERS","VOID","listen","unlistenByKey","MapBrowserEventHandler","constructor","map","moveTolerance","map_","clickTimeoutId_","emulateClicks_","dragging_","dragListenerKeys_","moveTolerance_","undefined","down_","element","getViewport","activePointers_","trackedTouches_","element_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","originalPointerMoveEvent_","relayedListenerKey_","POINTERMOVE","relayMoveEvent_","boundHandleTouchMove_","handleTouchMove_","bind","addEventListener","TOUCHMOVE","passive","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","updateActivePointers_","event","id","pointerId","type","POINTERUP","POINTERCANCEL","target","Object","values","handlePointerUp_","defaultPrevented","isMouseActionButton_","length","forEach","button","property","value","doc","getOwnerDocument","push","handlePointerMove_","getRootNode","isMoving_","POINTERDRAG","dragging","originalEvent","cancelable","preventDefault","Math","abs","clientX","clientY","disposeInternal","removeEventListener"],"sources":["D:/Work/Learning/demo/node_modules/ol/MapBrowserEventHandler.js"],"sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport {PASSIVE_EVENT_LISTENERS} from './has.js';\nimport {VOID} from './functions.js';\nimport {listen, unlistenByKey} from './events.js';\n\nclass MapBrowserEventHandler extends Target {\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    this.emulateClicks_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    this.down_ = null;\n\n    const element = this.map_.getViewport();\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    this.activePointers_ = [];\n\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERDOWN,\n      this.handlePointerDown_,\n      this\n    );\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERMOVE,\n      this.relayMoveEvent_,\n      this\n    );\n\n    /**\n     * @private\n     */\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n\n    this.element_.addEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_,\n      PASSIVE_EVENT_LISTENERS ? {passive: false} : false\n    );\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(\n      MapBrowserEventType.CLICK,\n      this.map_,\n      pointerEvent\n    );\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(\n        MapBrowserEventType.DBLCLICK,\n        this.map_,\n        pointerEvent\n      );\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(\n        /** @this {MapBrowserEventHandler} */\n        function () {\n          this.clickTimeoutId_ = undefined;\n          const newEvent = new MapBrowserEvent(\n            MapBrowserEventType.SINGLECLICK,\n            this.map_,\n            pointerEvent\n          );\n          this.dispatchEvent(newEvent);\n        }.bind(this),\n        250\n      );\n    }\n  }\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n    const id = event.pointerId;\n\n    if (\n      event.type == MapBrowserEventType.POINTERUP ||\n      event.type == MapBrowserEventType.POINTERCANCEL\n    ) {\n      delete this.trackedTouches_[id];\n      for (const pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (\n      event.type == MapBrowserEventType.POINTERDOWN ||\n      event.type == MapBrowserEventType.POINTERMOVE\n    ) {\n      this.trackedTouches_[id] = event;\n    }\n    this.activePointers_ = Object.values(this.trackedTouches_);\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERUP,\n      this.map_,\n      pointerEvent,\n      undefined,\n      undefined,\n      this.activePointers_\n    );\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n    if (\n      this.emulateClicks_ &&\n      !newEvent.defaultPrevented &&\n      !this.dragging_ &&\n      this.isMouseActionButton_(pointerEvent)\n    ) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerDown_(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERDOWN,\n      this.map_,\n      pointerEvent,\n      undefined,\n      undefined,\n      this.activePointers_\n    );\n    this.dispatchEvent(newEvent);\n\n    // Store a copy of the down event\n    this.down_ = /** @type {PointerEvent} */ ({});\n    for (const property in pointerEvent) {\n      const value = pointerEvent[property];\n      this.down_[property] = typeof value === 'function' ? VOID : value;\n    }\n\n    if (this.dragListenerKeys_.length === 0) {\n      const doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(\n        listen(\n          doc,\n          MapBrowserEventType.POINTERMOVE,\n          this.handlePointerMove_,\n          this\n        ),\n        listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(\n          this.element_,\n          MapBrowserEventType.POINTERCANCEL,\n          this.handlePointerUp_,\n          this\n        )\n      );\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(\n          listen(\n            this.element_.getRootNode(),\n            MapBrowserEventType.POINTERUP,\n            this.handlePointerUp_,\n            this\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(\n        MapBrowserEventType.POINTERDRAG,\n        this.map_,\n        pointerEvent,\n        this.dragging_,\n        undefined,\n        this.activePointers_\n      );\n      this.dispatchEvent(newEvent);\n    }\n  }\n\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  relayMoveEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(\n      new MapBrowserEvent(\n        MapBrowserEventType.POINTERMOVE,\n        this.map_,\n        pointerEvent,\n        dragging\n      )\n    );\n  }\n\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    const originalEvent = this.originalPointerMoveEvent_;\n    if (\n      (!originalEvent || originalEvent.defaultPrevented) &&\n      (typeof event.cancelable !== 'boolean' || event.cancelable === true)\n    ) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  isMoving_(pointerEvent) {\n    return (\n      this.dragging_ ||\n      Math.abs(pointerEvent.clientX - this.down_.clientX) >\n        this.moveTolerance_ ||\n      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_\n    );\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    this.element_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default MapBrowserEventHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}