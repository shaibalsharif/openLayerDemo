{"ast":null,"code":"/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\n\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n\n  closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n\n  let i, squaredDistance;\n\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n\n  while (index < end) {\n    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n    }\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n\n  return minSquaredDistance;\n}","map":{"version":3,"names":["lerp","squaredDistance","squaredDx","assignClosest","flatCoordinates","offset1","offset2","stride","x","y","closestPoint","x1","y1","dx","dy","offset","t","i","length","maxSquaredDelta","end","max","x2","y2","squaredDelta","arrayMaxSquaredDelta","ends","ii","multiArrayMaxSquaredDelta","endss","assignClosestPoint","maxDelta","isRing","minSquaredDistance","tmpPoint","NaN","index","Math","sqrt","assignClosestArrayPoint","assignClosestMultiArrayPoint"],"sources":["D:/Work/Learning/demo/node_modules/ol/geom/flat/closest.js"],"sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}