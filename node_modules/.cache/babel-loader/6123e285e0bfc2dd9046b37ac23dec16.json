{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\n\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n\n    this.extentChanged = true;\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n\n    this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.renderedPixelRatio;\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n\n    this.renderedProjection = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n\n    this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  }\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n\n\n  getData(pixel) {\n    const frameState = this.frameState;\n\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n\n      if (!(tile instanceof ImageTile || tile instanceof ReprojTile) || tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n\n    return false;\n  }\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels\n\n    const width = Math.round(getWidth(extent) / resolution * pixelRatio);\n    const height = Math.round(getHeight(extent) / resolution * pixelRatio);\n    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n\n    const dx = tileResolution * width / 2 / tilePixelRatio;\n    const dy = tileResolution * height / 2 / tilePixelRatio;\n    const canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    const findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;\n\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n          continue;\n        }\n\n        const tile = this.getTile(z, x, y, frameState);\n\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n\n            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {\n              this.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        let covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio; // set forward and inverse pixel transforms\n\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas\n\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    let clips, clipZs, currentClip;\n\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n\n      for (const tileCoordKey in tilesToDraw) {\n        const tile =\n        /** @type {import(\"../../ImageTile.js\").default} */\n        tilesToDraw[tileCoordKey];\n        const tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align\n\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n        const inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n\n                if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n\n                  context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile\n\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n\n    if (!image) {\n      return;\n    }\n\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n\n\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n\n\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n\n\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n      /** @type {import(\"../../Map.js\").PostRenderFunction} */\n      postRenderFunction);\n    }\n  }\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n\n\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n\n\n  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {\n    const tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n\n}\n\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","ImageTile","ReprojTile","TileRange","TileState","apply","applyTransform","compose","composeTransform","makeInverse","toString","toTransformString","containsCoordinate","createEmpty","equals","getHeight","getIntersection","getRotatedViewport","getTopLeft","getWidth","intersects","fromUserExtent","getUid","numberSafeCompareFunction","toSize","CanvasTileLayerRenderer","constructor","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","getPreload","getInterimTile","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","source","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","getImage","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","viewCenter","center","rotation","sourceRevision","getRevision","zDirection","extent","width","height","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","size","undefined","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","opacity","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","getBackground","context","canvas","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","length","zs","Object","keys","map","Number","sort","clips","clipZs","currentClip","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","image","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize"],"sources":["D:/Work/Learning/demo/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}