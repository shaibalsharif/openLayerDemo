{"ast":null,"code":"/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\n\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n\n    this.map_ = map;\n  }\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n\n\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n    composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n\n\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n    let result;\n    const viewState = frameState.viewState;\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n    const matches =\n    /** @type {Array<HitMatch<T>>} */\n    [];\n    const tmpCoord = [];\n\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n\n        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX() ? translatedCoordinate : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback, matches);\n          }\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    if (matches.length === 0) {\n      return undefined;\n    }\n\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => m.distanceSq += i * order);\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some(m => {\n      return result = m.callback(m.feature, m.layer, m.geometry);\n    });\n    return result;\n  }\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n\n\n  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n    const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n    return hasFeature !== undefined;\n  }\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n\n\n  getMap() {\n    return this.map_;\n  }\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n\n\n  renderFrame(frameState) {\n    abstract();\n  }\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n\n}\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\n\n\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;","map":{"version":3,"names":["Disposable","TRUE","abstract","compose","composeTransform","makeInverse","getWidth","shared","iconImageCache","inView","wrapX","MapRenderer","constructor","map","map_","dispatchRenderEvent","type","frameState","calculateMatrices2D","viewState","coordinateToPixelTransform","pixelToCoordinateTransform","size","resolution","rotation","center","forEachFeatureAtCoordinate","coordinate","hitTolerance","checkWrapped","callback","thisArg","layerFilter","thisArg2","result","managed","feature","layer","geometry","call","projection","translatedCoordinate","slice","offsets","canWrapX","projectionExtent","getExtent","worldWidth","push","layerStates","layerStatesArray","numLayers","length","matches","tmpCoord","i","j","layerState","hasRenderer","layerRenderer","getRenderer","source","getSource","coordinates","getWrapX","bind","undefined","order","forEach","m","distanceSq","sort","a","b","some","hasFeatureAtCoordinate","hasFeature","getMap","renderFrame","scheduleExpireIconCache","canExpireCache","postRenderFunctions","expireIconCache","expire"],"sources":["D:/Work/Learning/demo/node_modules/ol/renderer/Map.js"],"sourcesContent":["/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport {TRUE} from '../functions.js';\nimport {abstract} from '../util.js';\nimport {compose as composeTransform, makeInverse} from '../transform.js';\nimport {getWidth} from '../extent.js';\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\nimport {inView} from '../layer/Layer.js';\nimport {wrapX} from '../coordinate.js';\n\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n\n    composeTransform(\n      coordinateToPixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / viewState.resolution,\n      -1 / viewState.resolution,\n      -viewState.rotation,\n      -viewState.center[0],\n      -viewState.center[1]\n    );\n\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    callback,\n    thisArg,\n    layerFilter,\n    thisArg2\n  ) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n\n    const matches = /** @type {Array<HitMatch<T>>} */ ([]);\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (\n          layer.hasRenderer() &&\n          inView(layerState, viewState) &&\n          layerFilter.call(thisArg2, layer)\n        ) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX()\n              ? translatedCoordinate\n              : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(\n              null,\n              layerState.managed\n            );\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(\n              tmpCoord,\n              frameState,\n              hitTolerance,\n              callback,\n              matches\n            );\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => (m.distanceSq += i * order));\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some((m) => {\n      return (result = m.callback(m.feature, m.layer, m.geometry));\n    });\n    return result;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  hasFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    layerFilter,\n    thisArg\n  ) {\n    const hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      checkWrapped,\n      TRUE,\n      this,\n      layerFilter,\n      thisArg\n    );\n\n    return hasFeature !== undefined;\n  }\n\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAP,MAAuB,kBAAvB;AACA,SAAQC,IAAR,QAAmB,iBAAnB;AACA,SAAQC,QAAR,QAAuB,YAAvB;AACA,SAAQC,OAAO,IAAIC,gBAAnB,EAAqCC,WAArC,QAAuD,iBAAvD;AACA,SAAQC,QAAR,QAAuB,cAAvB;AACA,SAAQC,MAAM,IAAIC,cAAlB,QAAuC,4BAAvC;AACA,SAAQC,MAAR,QAAqB,mBAArB;AACA,SAAQC,KAAR,QAAoB,kBAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,WAAN,SAA0BX,UAA1B,CAAqC;EACnC;AACF;AACA;EACEY,WAAW,CAACC,GAAD,EAAM;IACf;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,IAAL,GAAYD,GAAZ;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEE,mBAAmB,CAACC,IAAD,EAAOC,UAAP,EAAmB;IACpCf,QAAQ;EACT;EAED;AACF;AACA;AACA;;;EACEgB,mBAAmB,CAACD,UAAD,EAAa;IAC9B,MAAME,SAAS,GAAGF,UAAU,CAACE,SAA7B;IACA,MAAMC,0BAA0B,GAAGH,UAAU,CAACG,0BAA9C;IACA,MAAMC,0BAA0B,GAAGJ,UAAU,CAACI,0BAA9C;IAEAjB,gBAAgB,CACdgB,0BADc,EAEdH,UAAU,CAACK,IAAX,CAAgB,CAAhB,IAAqB,CAFP,EAGdL,UAAU,CAACK,IAAX,CAAgB,CAAhB,IAAqB,CAHP,EAId,IAAIH,SAAS,CAACI,UAJA,EAKd,CAAC,CAAD,GAAKJ,SAAS,CAACI,UALD,EAMd,CAACJ,SAAS,CAACK,QANG,EAOd,CAACL,SAAS,CAACM,MAAV,CAAiB,CAAjB,CAPa,EAQd,CAACN,SAAS,CAACM,MAAV,CAAiB,CAAjB,CARa,CAAhB;IAWApB,WAAW,CAACgB,0BAAD,EAA6BD,0BAA7B,CAAX;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEM,0BAA0B,CACxBC,UADwB,EAExBV,UAFwB,EAGxBW,YAHwB,EAIxBC,YAJwB,EAKxBC,QALwB,EAMxBC,OANwB,EAOxBC,WAPwB,EAQxBC,QARwB,EASxB;IACA,IAAIC,MAAJ;IACA,MAAMf,SAAS,GAAGF,UAAU,CAACE,SAA7B;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;IACI,SAASO,0BAAT,CAAoCS,OAApC,EAA6CC,OAA7C,EAAsDC,KAAtD,EAA6DC,QAA7D,EAAuE;MACrE,OAAOR,QAAQ,CAACS,IAAT,CAAcR,OAAd,EAAuBK,OAAvB,EAAgCD,OAAO,GAAGE,KAAH,GAAW,IAAlD,EAAwDC,QAAxD,CAAP;IACD;;IAED,MAAME,UAAU,GAAGrB,SAAS,CAACqB,UAA7B;IAEA,MAAMC,oBAAoB,GAAG/B,KAAK,CAACiB,UAAU,CAACe,KAAX,EAAD,EAAqBF,UAArB,CAAlC;IACA,MAAMG,OAAO,GAAG,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,CAAhB;;IACA,IAAIH,UAAU,CAACI,QAAX,MAAyBf,YAA7B,EAA2C;MACzC,MAAMgB,gBAAgB,GAAGL,UAAU,CAACM,SAAX,EAAzB;MACA,MAAMC,UAAU,GAAGzC,QAAQ,CAACuC,gBAAD,CAA3B;MACAF,OAAO,CAACK,IAAR,CAAa,CAAC,CAACD,UAAF,EAAc,CAAd,CAAb,EAA+B,CAACA,UAAD,EAAa,CAAb,CAA/B;IACD;;IAED,MAAME,WAAW,GAAGhC,UAAU,CAACiC,gBAA/B;IACA,MAAMC,SAAS,GAAGF,WAAW,CAACG,MAA9B;IAEA,MAAMC,OAAO;IAAG;IAAmC,EAAnD;IACA,MAAMC,QAAQ,GAAG,EAAjB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,OAAO,CAACS,MAA5B,EAAoCG,CAAC,EAArC,EAAyC;MACvC,KAAK,IAAIC,CAAC,GAAGL,SAAS,GAAG,CAAzB,EAA4BK,CAAC,IAAI,CAAjC,EAAoC,EAAEA,CAAtC,EAAyC;QACvC,MAAMC,UAAU,GAAGR,WAAW,CAACO,CAAD,CAA9B;QACA,MAAMnB,KAAK,GAAGoB,UAAU,CAACpB,KAAzB;;QACA,IACEA,KAAK,CAACqB,WAAN,MACAjD,MAAM,CAACgD,UAAD,EAAatC,SAAb,CADN,IAEAa,WAAW,CAACO,IAAZ,CAAiBN,QAAjB,EAA2BI,KAA3B,CAHF,EAIE;UACA,MAAMsB,aAAa,GAAGtB,KAAK,CAACuB,WAAN,EAAtB;UACA,MAAMC,MAAM,GAAGxB,KAAK,CAACyB,SAAN,EAAf;;UACA,IAAIH,aAAa,IAAIE,MAArB,EAA6B;YAC3B,MAAME,WAAW,GAAGF,MAAM,CAACG,QAAP,KAChBvB,oBADgB,GAEhBd,UAFJ;YAGA,MAAMG,QAAQ,GAAGJ,0BAA0B,CAACuC,IAA3B,CACf,IADe,EAEfR,UAAU,CAACtB,OAFI,CAAjB;YAIAmB,QAAQ,CAAC,CAAD,CAAR,GAAcS,WAAW,CAAC,CAAD,CAAX,GAAiBpB,OAAO,CAACY,CAAD,CAAP,CAAW,CAAX,CAA/B;YACAD,QAAQ,CAAC,CAAD,CAAR,GAAcS,WAAW,CAAC,CAAD,CAAX,GAAiBpB,OAAO,CAACY,CAAD,CAAP,CAAW,CAAX,CAA/B;YACArB,MAAM,GAAGyB,aAAa,CAACjC,0BAAd,CACP4B,QADO,EAEPrC,UAFO,EAGPW,YAHO,EAIPE,QAJO,EAKPuB,OALO,CAAT;UAOD;;UACD,IAAInB,MAAJ,EAAY;YACV,OAAOA,MAAP;UACD;QACF;MACF;IACF;;IACD,IAAImB,OAAO,CAACD,MAAR,KAAmB,CAAvB,EAA0B;MACxB,OAAOc,SAAP;IACD;;IACD,MAAMC,KAAK,GAAG,IAAId,OAAO,CAACD,MAA1B;IACAC,OAAO,CAACe,OAAR,CAAgB,CAACC,CAAD,EAAId,CAAJ,KAAWc,CAAC,CAACC,UAAF,IAAgBf,CAAC,GAAGY,KAA/C;IACAd,OAAO,CAACkB,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACF,UAAF,GAAeG,CAAC,CAACH,UAAxC;IACAjB,OAAO,CAACqB,IAAR,CAAcL,CAAD,IAAO;MAClB,OAAQnC,MAAM,GAAGmC,CAAC,CAACvC,QAAF,CAAWuC,CAAC,CAACjC,OAAb,EAAsBiC,CAAC,CAAChC,KAAxB,EAA+BgC,CAAC,CAAC/B,QAAjC,CAAjB;IACD,CAFD;IAGA,OAAOJ,MAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEyC,sBAAsB,CACpBhD,UADoB,EAEpBV,UAFoB,EAGpBW,YAHoB,EAIpBC,YAJoB,EAKpBG,WALoB,EAMpBD,OANoB,EAOpB;IACA,MAAM6C,UAAU,GAAG,KAAKlD,0BAAL,CACjBC,UADiB,EAEjBV,UAFiB,EAGjBW,YAHiB,EAIjBC,YAJiB,EAKjB5B,IALiB,EAMjB,IANiB,EAOjB+B,WAPiB,EAQjBD,OARiB,CAAnB;IAWA,OAAO6C,UAAU,KAAKV,SAAtB;EACD;EAED;AACF;AACA;;;EACEW,MAAM,GAAG;IACP,OAAO,KAAK/D,IAAZ;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEgE,WAAW,CAAC7D,UAAD,EAAa;IACtBf,QAAQ;EACT;EAED;AACF;AACA;AACA;;;EACE6E,uBAAuB,CAAC9D,UAAD,EAAa;IAClC,IAAIT,cAAc,CAACwE,cAAf,EAAJ,EAAqC;MACnC/D,UAAU,CAACgE,mBAAX,CAA+BjC,IAA/B,CAAoCkC,eAApC;IACD;EACF;;AA9MkC;AAiNrC;AACA;AACA;AACA;;;AACA,SAASA,eAAT,CAAyBrE,GAAzB,EAA8BI,UAA9B,EAA0C;EACxCT,cAAc,CAAC2E,MAAf;AACD;;AAED,eAAexE,WAAf"},"metadata":{},"sourceType":"module"}