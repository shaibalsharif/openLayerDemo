{"ast":null,"code":"/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\n\nconst MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\n\nconst MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\n\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n\n    this.targetProj_ = targetProj;\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n\n      return transformInvCache[key];\n    };\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n\n\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n\n    this.triangles_ = [];\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n\n    this.wrapsXInSource_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n    /**\n     * @type {?number}\n     * @private\n     */\n\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n    /**\n     * @type {?number}\n     * @private\n     */\n\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n\n    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      }); // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n          const newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          } // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n\n\n          const minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          const maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }.bind(this));\n    }\n\n    transformInvCache = {};\n  }\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n\n\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  }\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n\n\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    const sourceWorldWidth =\n    /** @type {number} */\n    this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n\n    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n        let dx;\n\n        if (wrapsX) {\n          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n\n      this.wrapsXInSource_ = true;\n    } // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n\n\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n\n\n  calculateSourceExtent() {\n    const extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  }\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n\n\n  getTriangles() {\n    return this.triangles_;\n  }\n\n}\n\nexport default Triangulation;","map":{"version":3,"names":["boundingExtent","createEmpty","extendCoordinate","getArea","getBottomLeft","getBottomRight","getTopLeft","getTopRight","getWidth","intersects","getTransform","modulo","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","constructor","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","log2","addQuad_","leftBound","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","bind","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles"],"sources":["D:/Work/Learning/demo/node_modules/ol/reproj/Triangulation.js"],"sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(\n        function (triangle) {\n          if (\n            Math.max(\n              triangle.source[0][0],\n              triangle.source[1][0],\n              triangle.source[2][0]\n            ) -\n              leftBound >\n            this.sourceWorldWidth_ / 2\n          ) {\n            const newTriangle = [\n              [triangle.source[0][0], triangle.source[0][1]],\n              [triangle.source[1][0], triangle.source[1][1]],\n              [triangle.source[2][0], triangle.source[2][1]],\n            ];\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[0][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[1][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[2][0] -= this.sourceWorldWidth_;\n            }\n\n            // Rarely (if the extent contains both the dateline and prime meridian)\n            // the shift can in turn break some triangles.\n            // Detect this here and don't shift in such cases.\n            const minX = Math.min(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            const maxX = Math.max(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\n              triangle.source = newTriangle;\n            }\n          }\n        }.bind(this)\n      );\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}