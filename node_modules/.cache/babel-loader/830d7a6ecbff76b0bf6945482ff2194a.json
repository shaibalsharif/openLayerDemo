{"ast":null,"code":"/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport { DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, createProjection, disableCoordinateWarning, fromUserCoordinate, fromUserExtent, getUserProjection, toUserCoordinate, toUserExtent } from './proj.js';\nimport { VOID } from './functions.js';\nimport { add as addCoordinate, equals as coordinatesEqual, equals, rotate as rotateCoordinate } from './coordinate.js';\nimport { assert } from './asserts.js';\nimport { none as centerNone, createExtent } from './centerconstraint.js';\nimport { clamp, modulo } from './math.js';\nimport { createMinMaxResolution, createSnapToPower, createSnapToResolutions } from './resolutionconstraint.js';\nimport { createSnapToN, createSnapToZero, disable, none as rotationNone } from './rotationconstraint.js';\nimport { easeOut, inAndOut } from './easing.js';\nimport { getCenter, getForViewAndSize, getHeight, getWidth, isEmpty } from './extent.js';\nimport { linearFindNearest } from './array.js';\nimport { fromExtent as polygonFromExtent } from './geom/Polygon.js';\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center.\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\n\nconst DEFAULT_MIN_ZOOM = 0;\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\n\nclass View extends BaseObject {\n  /**\n   * @param {ViewOptions} [options] View options.\n   */\n  constructor(options) {\n    super();\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n\n    this.on;\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n\n    this.once;\n    /***\n     * @type {ViewOnSignature<void>}\n     */\n\n    this.un;\n    options = Object.assign({}, options);\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.hints_ = [0, 0];\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n\n    this.animations_ = [];\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.updateAnimationKey_;\n    /**\n     * @private\n     * @const\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n    /**\n     * @private\n     * @type {import(\"./size.js\").Size}\n     */\n\n    this.viewportSize_ = [100, 100];\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n\n    this.targetCenter_ = null;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.targetResolution_;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.targetRotation_;\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n\n    this.nextCenter_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.nextResolution_;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.nextRotation_;\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n\n    this.cancelAnchor_ = undefined;\n\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, this.projection_);\n    }\n\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, this.projection_);\n    }\n\n    this.applyOptions_(options);\n  }\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n\n\n  applyOptions_(options) {\n    const properties = Object.assign({}, options);\n\n    for (const key in ViewProperty) {\n      delete properties[key];\n    }\n\n    this.setProperties(properties, true);\n    const resolutionConstraintInfo = createResolutionConstraint(options);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n\n    this.resolutions_ = options.resolutions;\n    /**\n     * @type {Array<number>|undefined}\n     * @private\n     */\n\n    this.padding_ = options.padding;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n    const centerConstraint = createCenterConstraint(options);\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\n    const rotationConstraint = createRotationConstraint(options);\n    /**\n     * @private\n     * @type {Constraints}\n     */\n\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint\n    };\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n    this.setCenterInternal(options.center !== undefined ? options.center : null);\n\n    if (options.resolution !== undefined) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== undefined) {\n      this.setZoom(options.zoom);\n    }\n  }\n  /**\n   * Padding (in css pixels).\n   * If the map viewport is partially covered with other content (overlays) along\n   * its edges, this setting allows to shift the center of the viewport away from that\n   * content. The order of the values in the array is top, right, bottom, left.\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n   * @type {Array<number>|undefined}\n   * @api\n   */\n\n\n  get padding() {\n    return this.padding_;\n  }\n\n  set padding(padding) {\n    let oldPadding = this.padding_;\n    this.padding_ = padding;\n    const center = this.getCenter();\n\n    if (center) {\n      const newPadding = padding || [0, 0, 0, 0];\n      oldPadding = oldPadding || [0, 0, 0, 0];\n      const resolution = this.getResolution();\n      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n    }\n  }\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n\n\n  getUpdatedOptions_(newOptions) {\n    const options = this.getProperties(); // preserve resolution (or zoom)\n\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    } // preserve center\n\n\n    options.center = this.getCenterInternal(); // preserve rotation\n\n    options.rotation = this.getRotation();\n    return Object.assign({}, options, newOptions);\n  }\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n\n\n  animate(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n\n    const args = new Array(arguments.length);\n\n    for (let i = 0; i < args.length; ++i) {\n      let options = arguments[i];\n\n      if (options.center) {\n        options = Object.assign({}, options);\n        options.center = fromUserCoordinate(options.center, this.getProjection());\n      }\n\n      if (options.anchor) {\n        options = Object.assign({}, options);\n        options.anchor = fromUserCoordinate(options.anchor, this.getProjection());\n      }\n\n      args[i] = options;\n    }\n\n    this.animateInternal.apply(this, args);\n  }\n  /**\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n   */\n\n\n  animateInternal(var_args) {\n    let animationCount = arguments.length;\n    let callback;\n\n    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    let i = 0;\n\n    for (; i < animationCount && !this.isDef(); ++i) {\n      // if view properties are not yet set, shortcut to the final state\n      const state = arguments[i];\n\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n    }\n\n    if (i === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n\n      return;\n    }\n\n    let start = Date.now();\n    let center = this.targetCenter_.slice();\n    let resolution = this.targetResolution_;\n    let rotation = this.targetRotation_;\n    const series = [];\n\n    for (; i < animationCount; ++i) {\n      const options =\n      /** @type {AnimationOptions} */\n      arguments[i];\n      const animation = {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut,\n        callback: callback\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      } // check if animation is a no-op\n\n\n      if (isNoopAnimation(animation)) {\n        animation.complete = true; // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n\n      series.push(animation);\n    }\n\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  }\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n\n\n  getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  }\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n\n\n  getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  }\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n\n\n  cancelAnimations() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    let anchor;\n\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\n      const series = this.animations_[i];\n\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n\n      if (!anchor) {\n        for (let j = 0, jj = series.length; j < jj; ++j) {\n          const animation = series[j];\n\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  }\n  /**\n   * Update all animations.\n   */\n\n\n  updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n\n    if (!this.getAnimating()) {\n      return;\n    }\n\n    const now = Date.now();\n    let more = false;\n\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\n      const series = this.animations_[i];\n      let seriesComplete = true;\n\n      for (let j = 0, jj = series.length; j < jj; ++j) {\n        const animation = series[j];\n\n        if (animation.complete) {\n          continue;\n        }\n\n        const elapsed = now - animation.start;\n        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n\n        const progress = animation.easing(fraction);\n\n        if (animation.sourceCenter) {\n          const x0 = animation.sourceCenter[0];\n          const y0 = animation.sourceCenter[1];\n          const x1 = animation.targetCenter[0];\n          const y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          const x = x0 + progress * (x1 - x0);\n          const y = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x, y];\n        }\n\n        if (animation.sourceResolution && animation.targetResolution) {\n          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n\n          if (animation.anchor) {\n            const size = this.getViewportSize_(this.getRotation());\n            const constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);\n            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);\n          }\n\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n\n        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\n          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n\n          if (animation.anchor) {\n            const constrainedRotation = this.constraints_.rotation(rotation, true);\n            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);\n          }\n\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n\n        this.applyTargetState_(true);\n        more = true;\n\n        if (!animation.complete) {\n          break;\n        }\n      }\n\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        const callback = series[0].callback;\n\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    } // prune completed series\n\n\n    this.animations_ = this.animations_.filter(Boolean);\n\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));\n    }\n  }\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n   */\n\n\n  calculateCenterRotate(rotation, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n\n    return center;\n  }\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n   */\n\n\n  calculateCenterZoom(resolution, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    const currentResolution = this.getResolution();\n\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n      const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n      center = [x, y];\n    }\n\n    return center;\n  }\n  /**\n   * Returns the current viewport size.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n\n\n  getViewportSize_(rotation) {\n    const size = this.viewportSize_;\n\n    if (rotation) {\n      const w = size[0];\n      const h = size[1];\n      return [Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)), Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))];\n    } else {\n      return size;\n    }\n  }\n  /**\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n   * to avoid performance hit and layout reflow.\n   * This should be done on map size change.\n   * Note: the constraints are not resolved during an animation to avoid stopping it\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\n   */\n\n\n  setViewportSize(size) {\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\n\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  }\n  /**\n   * Get the view center.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n\n\n  getCenter() {\n    const center = this.getCenterInternal();\n\n    if (!center) {\n      return center;\n    }\n\n    return toUserCoordinate(center, this.getProjection());\n  }\n  /**\n   * Get the view center without transforming to user projection.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   */\n\n\n  getCenterInternal() {\n    return (\n      /** @type {import(\"./coordinate.js\").Coordinate|undefined} */\n      this.get(ViewProperty.CENTER)\n    );\n  }\n  /**\n   * @return {Constraints} Constraints.\n   */\n\n\n  getConstraints() {\n    return this.constraints_;\n  }\n  /**\n   * @return {boolean} Resolution constraint is set\n   */\n\n\n  getConstrainResolution() {\n    return this.get('constrainResolution');\n  }\n  /**\n   * @param {Array<number>} [hints] Destination array.\n   * @return {Array<number>} Hint.\n   */\n\n\n  getHints(hints) {\n    if (hints !== undefined) {\n      hints[0] = this.hints_[0];\n      hints[1] = this.hints_[1];\n      return hints;\n    } else {\n      return this.hints_.slice();\n    }\n  }\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided, the size\n   * of the map that uses this view will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   * @api\n   */\n\n\n  calculateExtent(size) {\n    const extent = this.calculateExtentInternal(size);\n    return toUserExtent(extent, this.getProjection());\n  }\n  /**\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\n   * the map's last known viewport size will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n\n\n  calculateExtentInternal(size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const center =\n    /** @type {!import(\"./coordinate.js\").Coordinate} */\n    this.getCenterInternal();\n    assert(center, 1); // The view center is not defined\n\n    const resolution =\n    /** @type {!number} */\n    this.getResolution();\n    assert(resolution !== undefined, 2); // The view resolution is not defined\n\n    const rotation =\n    /** @type {!number} */\n    this.getRotation();\n    assert(rotation !== undefined, 3); // The view rotation is not defined\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  }\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n\n\n  getMaxResolution() {\n    return this.maxResolution_;\n  }\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n\n\n  getMinResolution() {\n    return this.minResolution_;\n  }\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n\n\n  getMaxZoom() {\n    return (\n      /** @type {number} */\n      this.getZoomForResolution(this.minResolution_)\n    );\n  }\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n\n\n  setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      maxZoom: zoom\n    }));\n  }\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n\n\n  getMinZoom() {\n    return (\n      /** @type {number} */\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  }\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n\n\n  setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      minZoom: zoom\n    }));\n  }\n  /**\n   * Set whether the view should allow intermediary zoom levels.\n   * @param {boolean} enabled Whether the resolution is constrained.\n   * @api\n   */\n\n\n  setConstrainResolution(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      constrainResolution: enabled\n    }));\n  }\n  /**\n   * Get the view projection.\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n   * @api\n   */\n\n\n  getProjection() {\n    return this.projection_;\n  }\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n\n\n  getResolution() {\n    return (\n      /** @type {number|undefined} */\n      this.get(ViewProperty.RESOLUTION)\n    );\n  }\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n\n\n  getResolutions() {\n    return this.resolutions_;\n  }\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n\n\n  getResolutionForExtent(extent, size) {\n    return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), size);\n  }\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   */\n\n\n  getResolutionForExtentInternal(extent, size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const xResolution = getWidth(extent) / size[0];\n    const yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  }\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n\n\n  getResolutionForValueFunction(power) {\n    power = power || 2;\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        const resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  }\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n\n\n  getRotation() {\n    return (\n      /** @type {number} */\n      this.get(ViewProperty.ROTATION)\n    );\n  }\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n\n\n  getValueForResolutionFunction(power) {\n    const logPower = Math.log(power || 2);\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / logPower;\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        const value = Math.log(maxResolution / resolution) / logPower / max;\n        return value;\n      }\n    );\n  }\n  /**\n   * Returns the size of the viewport minus padding.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n   */\n\n\n  getViewportSizeMinusPadding_(rotation) {\n    let size = this.getViewportSize_(rotation);\n    const padding = this.padding_;\n\n    if (padding) {\n      size = [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]];\n    }\n\n    return size;\n  }\n  /**\n   * @return {State} View state.\n   */\n\n\n  getState() {\n    const projection = this.getProjection();\n    const resolution = this.getResolution();\n    const rotation = this.getRotation();\n    let center =\n    /** @type {import(\"./coordinate.js\").Coordinate} */\n    this.getCenterInternal();\n    const padding = this.padding_;\n\n    if (padding) {\n      const reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);\n    }\n\n    return {\n      center: center.slice(0),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation: rotation,\n      zoom: this.getZoom()\n    };\n  }\n  /**\n   * Get the current zoom level. This method may return non-integer zoom levels\n   * if the view does not constrain the resolution, or if an interaction or\n   * animation is underway.\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n\n\n  getZoom() {\n    let zoom;\n    const resolution = this.getResolution();\n\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n\n    return zoom;\n  }\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n\n\n  getZoomForResolution(resolution) {\n    let offset = this.minZoom_ || 0;\n    let max, zoomFactor;\n\n    if (this.resolutions_) {\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  }\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n\n\n  getResolutionForZoom(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n\n      const baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);\n      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));\n    } else {\n      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);\n    }\n  }\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions} [options] Options.\n   * @api\n   */\n\n\n  fit(geometryOrExtent, options) {\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n    let geometry;\n    assert(Array.isArray(geometryOrExtent) || typeof\n    /** @type {?} */\n    geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`\n\n    if (Array.isArray(geometryOrExtent)) {\n      assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = polygonFromExtent(extent);\n    } else if (geometryOrExtent.getType() === 'Circle') {\n      const extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());\n      geometry = polygonFromExtent(extent);\n      geometry.rotate(this.getRotation(), getCenter(extent));\n    } else {\n      const userProjection = getUserProjection();\n\n      if (userProjection) {\n        geometry =\n        /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n        geometryOrExtent.clone().transform(userProjection, this.getProjection());\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n\n    this.fitInternal(geometry, options);\n  }\n  /**\n   * Calculate rotated extent\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n   */\n\n\n  rotatedExtentForGeometry(geometry) {\n    const rotation = this.getRotation();\n    const cosAngle = Math.cos(rotation);\n    const sinAngle = Math.sin(-rotation);\n    const coords = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    let minRotX = +Infinity;\n    let minRotY = +Infinity;\n    let maxRotX = -Infinity;\n    let maxRotY = -Infinity;\n\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  }\n  /**\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @param {FitOptions} [options] Options.\n   */\n\n\n  fitInternal(geometry, options) {\n    options = options || {};\n    let size = options.size;\n\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n\n    const padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    const nearest = options.nearest !== undefined ? options.nearest : false;\n    let minResolution;\n\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry); // calculate resolution\n\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\n    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1); // calculate center\n\n    const rotation = this.getRotation();\n    const sinAngle = Math.sin(rotation);\n    const cosAngle = Math.cos(rotation);\n    const centerRot = getCenter(rotatedExtent);\n    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;\n    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\n    const callback = options.callback ? options.callback : VOID;\n\n    if (options.duration !== undefined) {\n      this.animateInternal({\n        resolution: resolution,\n        center: center,\n        duration: options.duration,\n        easing: options.easing\n      }, callback);\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  }\n  /**\n   * Center on coordinate and view position.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   * @api\n   */\n\n\n  centerOn(coordinate, size, position) {\n    this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);\n  }\n  /**\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   */\n\n\n  centerOnInternal(coordinate, size, position) {\n    this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));\n  }\n  /**\n   * Calculates the shift between map and viewport center.\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {import(\"./size.js\").Size} size Size.\n   * @return {Array<number>|undefined} Center shift.\n   */\n\n\n  calculateCenterShift(center, resolution, rotation, size) {\n    let centerShift;\n    const padding = this.padding_;\n\n    if (padding && center) {\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      const shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);\n      centerShift = [center[0] - shiftedCenter[0], center[1] - shiftedCenter[1]];\n    }\n\n    return centerShift;\n  }\n  /**\n   * @return {boolean} Is defined.\n   */\n\n\n  isDef() {\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\n  }\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   * @api\n   */\n\n\n  adjustCenter(deltaCoordinates) {\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);\n  }\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   */\n\n\n  adjustCenterInternal(deltaCoordinates) {\n    const center = this.targetCenter_;\n    this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);\n  }\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n\n\n  adjustResolution(ratio, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  }\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n\n\n  adjustResolutionInternal(ratio, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const size = this.getViewportSize_(this.getRotation());\n    const newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);\n\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\n    }\n\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  }\n  /**\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom level.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n\n\n  adjustZoom(delta, anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\n  }\n  /**\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   * @api\n   */\n\n\n  adjustRotation(delta, anchor) {\n    if (anchor) {\n      anchor = fromUserCoordinate(anchor, this.getProjection());\n    }\n\n    this.adjustRotationInternal(delta, anchor);\n  }\n  /**\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   */\n\n\n  adjustRotationInternal(delta, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);\n\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\n    }\n\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  }\n  /**\n   * Set the center of the current view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n\n\n  setCenter(center) {\n    this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);\n  }\n  /**\n   * Set the center using the view projection (not the user projection).\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   */\n\n\n  setCenterInternal(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  }\n  /**\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n\n\n  setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  }\n  /**\n   * Set the resolution for this view. Any resolution constraint will apply.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n\n\n  setResolution(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  }\n  /**\n   * Set the rotation for this view. Any rotation constraint will apply.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n\n\n  setRotation(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  }\n  /**\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n\n\n  setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  }\n  /**\n   * Recompute rotation/resolution/center based on target values.\n   * Note: we have to compute rotation first, then resolution and center considering that\n   * parameters can influence one another in case a view extent constraint is present.\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\n   * @private\n   */\n\n\n  applyTargetState_(doNotCancelAnims, forceMoving) {\n    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving; // compute rotation\n\n    const newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);\n    const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));\n\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set('zoom', this.getZoom(), true);\n    }\n\n    if (!newCenter || !this.get(ViewProperty.CENTER) || !equals(this.get(ViewProperty.CENTER), newCenter)) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n\n    if (this.getAnimating() && !doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n\n    this.cancelAnchor_ = undefined;\n  }\n  /**\n   * If any constraints need to be applied, an animation will be triggered.\n   * This is typically done on interaction end.\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\n   * without animation.\n   * @param {number} [duration] The animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n\n\n  resolveConstraints(duration, resolutionDirection, anchor) {\n    duration = duration !== undefined ? duration : 200;\n    const direction = resolutionDirection || 0;\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);\n    const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));\n\n    if (duration === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n    this.cancelAnchor_ = undefined;\n\n    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals(this.getCenterInternal(), newCenter)) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration,\n        easing: easeOut,\n        anchor: anchor\n      });\n    }\n  }\n  /**\n   * Notify the View that an interaction has started.\n   * The view state will be resolved to a stable one if needed\n   * (depending on its constraints).\n   * @api\n   */\n\n\n  beginInteraction() {\n    this.resolveConstraints(0);\n    this.setHint(ViewHint.INTERACTING, 1);\n  }\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n\n\n  endInteraction(duration, resolutionDirection, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\n  }\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n\n\n  endInteractionInternal(duration, resolutionDirection, anchor) {\n    this.setHint(ViewHint.INTERACTING, -1);\n    this.resolveConstraints(duration, resolutionDirection, anchor);\n  }\n  /**\n   * Get a valid position for the view center according to the current constraints.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\n   * This is useful to guess a valid center position at a different zoom level.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n   */\n\n\n  getConstrainedCenter(targetCenter, targetResolution) {\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);\n  }\n  /**\n   * Get a valid zoom level according to the current view constraints.\n   * @param {number|undefined} targetZoom Target zoom.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid zoom level.\n   */\n\n\n  getConstrainedZoom(targetZoom, direction) {\n    const targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));\n  }\n  /**\n   * Get a valid resolution according to the current view constraints.\n   * @param {number|undefined} targetResolution Target resolution.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid resolution.\n   */\n\n\n  getConstrainedResolution(targetResolution, direction) {\n    direction = direction || 0;\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.resolution(targetResolution, direction, size);\n  }\n\n}\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\n\n\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\n\n\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    const smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    const extent = projection.getExtent().slice();\n    extent[0] = -Infinity;\n    extent[2] = Infinity;\n    return createExtent(extent, false, false);\n  }\n\n  return centerNone;\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\n\nexport function createResolutionConstraint(options) {\n  let resolutionConstraint;\n  let maxResolution;\n  let minResolution; // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n\n  const defaultMaxZoom = 28;\n  const defaultZoomFactor = 2;\n  let minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n  let maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n  const zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n  const multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;\n  const smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;\n  const showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  const projExtent = projection.getExtent();\n  let constrainOnlyCenter = options.constrainOnlyCenter;\n  let extent = options.extent;\n\n  if (!multiWorld && !extent && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent = projExtent;\n  }\n\n  if (options.resolutions !== undefined) {\n    const resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);\n    } else {\n      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);\n    }\n  } else {\n    // calculate the default min and max resolution\n    const size = !projExtent ? // use an extent that can fit the whole world if need be\n    360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));\n    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence\n\n    maxResolution = options.maxResolution;\n\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    } // user provided minResolution takes precedence\n\n\n    minResolution = options.minResolution;\n\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    } // given discrete zoom levels, minResolution may be different than provided\n\n\n    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);\n    } else {\n      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);\n    }\n  }\n\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor\n  };\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\n\nexport function createRotationConstraint(options) {\n  const enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;\n\n  if (enableRotation) {\n    const constrainRotation = options.constrainRotation;\n\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return rotationNone;\n    } else if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    } else {\n      return rotationNone;\n    }\n  } else {\n    return disable;\n  }\n}\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\n\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\n\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n  // calculate rotated position\n  const cosAngle = Math.cos(-rotation);\n  let sinAngle = Math.sin(-rotation);\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position[0]) * resolution;\n  rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle\n\n  sinAngle = -sinAngle; // go back to original rotation\n\n  const centerX = rotX * cosAngle - rotY * sinAngle;\n  const centerY = rotY * cosAngle + rotX * sinAngle;\n  return [centerX, centerY];\n}\n\nexport default View;","map":{"version":3,"names":["BaseObject","ViewHint","ViewProperty","DEFAULT_TILE_SIZE","METERS_PER_UNIT","createProjection","disableCoordinateWarning","fromUserCoordinate","fromUserExtent","getUserProjection","toUserCoordinate","toUserExtent","VOID","add","addCoordinate","equals","coordinatesEqual","rotate","rotateCoordinate","assert","none","centerNone","createExtent","clamp","modulo","createMinMaxResolution","createSnapToPower","createSnapToResolutions","createSnapToN","createSnapToZero","disable","rotationNone","easeOut","inAndOut","getCenter","getForViewAndSize","getHeight","getWidth","isEmpty","linearFindNearest","fromExtent","polygonFromExtent","DEFAULT_MIN_ZOOM","View","constructor","options","on","once","un","Object","assign","hints_","animations_","updateAnimationKey_","projection_","projection","viewportSize_","targetCenter_","targetResolution_","targetRotation_","nextCenter_","nextResolution_","nextRotation_","cancelAnchor_","undefined","center","extent","applyOptions_","properties","key","setProperties","resolutionConstraintInfo","createResolutionConstraint","maxResolution_","maxResolution","minResolution_","minResolution","zoomFactor_","zoomFactor","resolutions_","resolutions","padding_","padding","minZoom_","minZoom","centerConstraint","createCenterConstraint","resolutionConstraint","constraint","rotationConstraint","createRotationConstraint","constraints_","resolution","rotation","setRotation","setCenterInternal","setResolution","zoom","setZoom","oldPadding","newPadding","getResolution","offsetX","offsetY","getUpdatedOptions_","newOptions","getProperties","getZoom","getCenterInternal","getRotation","animate","var_args","isDef","getAnimating","resolveConstraints","args","Array","arguments","length","i","getProjection","anchor","animateInternal","apply","animationCount","callback","state","animationCallback","start","Date","now","slice","series","animation","complete","duration","easing","sourceCenter","targetCenter","sourceResolution","targetResolution","getResolutionForZoom","sourceRotation","delta","Math","PI","targetRotation","isNoopAnimation","push","setHint","ANIMATING","updateAnimations_","getInteracting","INTERACTING","cancelAnimations","ii","j","jj","NaN","cancelAnimationFrame","more","seriesComplete","elapsed","fraction","progress","x0","y0","x1","y1","x","y","size","getViewportSize_","constrainedResolution","calculateCenterZoom","applyTargetState_","constrainedRotation","calculateCenterRotate","filter","Boolean","requestAnimationFrame","bind","currentCenter","currentResolution","w","h","abs","cos","sin","setViewportSize","isArray","get","CENTER","getConstraints","getConstrainResolution","getHints","hints","calculateExtent","calculateExtentInternal","getViewportSizeMinusPadding_","getMaxResolution","getMinResolution","getMaxZoom","getZoomForResolution","setMaxZoom","maxZoom","getMinZoom","setMinZoom","setConstrainResolution","enabled","constrainResolution","RESOLUTION","getResolutions","getResolutionForExtent","getResolutionForExtentInternal","xResolution","yResolution","max","getResolutionForValueFunction","power","getConstrainedResolution","log","value","pow","ROTATION","getValueForResolutionFunction","logPower","getState","reducedSize","calculateCenterOn","nextCenter","nextResolution","nextRotation","offset","nearest","baseLevel","floor","fit","geometryOrExtent","geometry","getSimplifiedGeometry","getType","getExtent","userProjection","clone","transform","fitInternal","rotatedExtentForGeometry","cosAngle","sinAngle","coords","getFlatCoordinates","stride","getStride","minRotX","Infinity","minRotY","maxRotX","maxRotY","rotX","rotY","min","rotatedExtent","isNaN","centerRot","centerX","centerY","getConstrainedCenter","centerOn","coordinate","position","centerOnInternal","calculateCenterShift","centerShift","shiftedCenter","adjustCenter","deltaCoordinates","setCenter","adjustCenterInternal","adjustResolution","ratio","adjustResolutionInternal","isMoving","newResolution","adjustZoom","adjustRotation","adjustRotationInternal","newRotation","hint","changed","doNotCancelAnims","forceMoving","newCenter","set","resolutionDirection","direction","beginInteraction","endInteraction","endInteractionInternal","getConstrainedZoom","targetZoom","targetRes","returnValue","setTimeout","smooth","smoothExtentConstraint","constrainOnlyCenter","multiWorld","isGlobal","defaultMaxZoom","defaultZoomFactor","smoothResolutionConstraint","showFullExtent","projExtent","degrees","getMetersPerUnit","defaultMaxResolution","defaultMinResolution","enableRotation","constrainRotation"],"sources":["D:/Work/Learning/demo/node_modules/ol/View.js"],"sourcesContent":["/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {\n  METERS_PER_UNIT,\n  createProjection,\n  disableCoordinateWarning,\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from './proj.js';\nimport {VOID} from './functions.js';\nimport {\n  add as addCoordinate,\n  equals as coordinatesEqual,\n  equals,\n  rotate as rotateCoordinate,\n} from './coordinate.js';\nimport {assert} from './asserts.js';\nimport {none as centerNone, createExtent} from './centerconstraint.js';\nimport {clamp, modulo} from './math.js';\nimport {\n  createMinMaxResolution,\n  createSnapToPower,\n  createSnapToResolutions,\n} from './resolutionconstraint.js';\nimport {\n  createSnapToN,\n  createSnapToZero,\n  disable,\n  none as rotationNone,\n} from './rotationconstraint.js';\nimport {easeOut, inAndOut} from './easing.js';\nimport {\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n  isEmpty,\n} from './extent.js';\nimport {linearFindNearest} from './array.js';\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center.\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nconst DEFAULT_MIN_ZOOM = 0;\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\nclass View extends BaseObject {\n  /**\n   * @param {ViewOptions} [options] View options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ViewOnSignature<void>}\n     */\n    this.un;\n\n    options = Object.assign({}, options);\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.hints_ = [0, 0];\n\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n    this.animations_ = [];\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n\n    /**\n     * @private\n     * @const\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n\n    /**\n     * @private\n     * @type {import(\"./size.js\").Size}\n     */\n    this.viewportSize_ = [100, 100];\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.targetCenter_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetResolution_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.nextCenter_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextResolution_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.cancelAnchor_ = undefined;\n\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, this.projection_);\n    }\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, this.projection_);\n    }\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n  applyOptions_(options) {\n    const properties = Object.assign({}, options);\n    for (const key in ViewProperty) {\n      delete properties[key];\n    }\n    this.setProperties(properties, true);\n\n    const resolutionConstraintInfo = createResolutionConstraint(options);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n\n    /**\n     * @type {Array<number>|undefined}\n     * @private\n     */\n    this.padding_ = options.padding;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n\n    const centerConstraint = createCenterConstraint(options);\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\n    const rotationConstraint = createRotationConstraint(options);\n\n    /**\n     * @private\n     * @type {Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint,\n    };\n\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n    this.setCenterInternal(\n      options.center !== undefined ? options.center : null\n    );\n    if (options.resolution !== undefined) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== undefined) {\n      this.setZoom(options.zoom);\n    }\n  }\n\n  /**\n   * Padding (in css pixels).\n   * If the map viewport is partially covered with other content (overlays) along\n   * its edges, this setting allows to shift the center of the viewport away from that\n   * content. The order of the values in the array is top, right, bottom, left.\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n   * @type {Array<number>|undefined}\n   * @api\n   */\n  get padding() {\n    return this.padding_;\n  }\n  set padding(padding) {\n    let oldPadding = this.padding_;\n    this.padding_ = padding;\n    const center = this.getCenter();\n    if (center) {\n      const newPadding = padding || [0, 0, 0, 0];\n      oldPadding = oldPadding || [0, 0, 0, 0];\n      const resolution = this.getResolution();\n      const offsetX =\n        (resolution / 2) *\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n      const offsetY =\n        (resolution / 2) *\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n    }\n  }\n\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n  getUpdatedOptions_(newOptions) {\n    const options = this.getProperties();\n\n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n\n    // preserve center\n    options.center = this.getCenterInternal();\n\n    // preserve rotation\n    options.rotation = this.getRotation();\n\n    return Object.assign({}, options, newOptions);\n  }\n\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  animate(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n    const args = new Array(arguments.length);\n    for (let i = 0; i < args.length; ++i) {\n      let options = arguments[i];\n      if (options.center) {\n        options = Object.assign({}, options);\n        options.center = fromUserCoordinate(\n          options.center,\n          this.getProjection()\n        );\n      }\n      if (options.anchor) {\n        options = Object.assign({}, options);\n        options.anchor = fromUserCoordinate(\n          options.anchor,\n          this.getProjection()\n        );\n      }\n      args[i] = options;\n    }\n    this.animateInternal.apply(this, args);\n  }\n\n  /**\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n   */\n  animateInternal(var_args) {\n    let animationCount = arguments.length;\n    let callback;\n    if (\n      animationCount > 1 &&\n      typeof arguments[animationCount - 1] === 'function'\n    ) {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    let i = 0;\n    for (; i < animationCount && !this.isDef(); ++i) {\n      // if view properties are not yet set, shortcut to the final state\n      const state = arguments[i];\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n    }\n    if (i === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n      return;\n    }\n\n    let start = Date.now();\n    let center = this.targetCenter_.slice();\n    let resolution = this.targetResolution_;\n    let rotation = this.targetRotation_;\n    const series = [];\n    for (; i < animationCount; ++i) {\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\n\n      const animation = {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut,\n        callback: callback,\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        const delta =\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      // check if animation is a no-op\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  }\n\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  }\n\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  }\n\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  cancelAnimations() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    let anchor;\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\n      const series = this.animations_[i];\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n      if (!anchor) {\n        for (let j = 0, jj = series.length; j < jj; ++j) {\n          const animation = series[j];\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  }\n\n  /**\n   * Update all animations.\n   */\n  updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    const now = Date.now();\n    let more = false;\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\n      const series = this.animations_[i];\n      let seriesComplete = true;\n      for (let j = 0, jj = series.length; j < jj; ++j) {\n        const animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        const elapsed = now - animation.start;\n        let fraction =\n          animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        const progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          const x0 = animation.sourceCenter[0];\n          const y0 = animation.sourceCenter[1];\n          const x1 = animation.targetCenter[0];\n          const y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          const x = x0 + progress * (x1 - x0);\n          const y = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x, y];\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          const resolution =\n            progress === 1\n              ? animation.targetResolution\n              : animation.sourceResolution +\n                progress *\n                  (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            const size = this.getViewportSize_(this.getRotation());\n            const constrainedResolution = this.constraints_.resolution(\n              resolution,\n              0,\n              size,\n              true\n            );\n            this.targetCenter_ = this.calculateCenterZoom(\n              constrainedResolution,\n              animation.anchor\n            );\n          }\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n        if (\n          animation.sourceRotation !== undefined &&\n          animation.targetRotation !== undefined\n        ) {\n          const rotation =\n            progress === 1\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\n                Math.PI\n              : animation.sourceRotation +\n                progress *\n                  (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            const constrainedRotation = this.constraints_.rotation(\n              rotation,\n              true\n            );\n            this.targetCenter_ = this.calculateCenterRotate(\n              constrainedRotation,\n              animation.anchor\n            );\n          }\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n        this.applyTargetState_(true);\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        const callback = series[0].callback;\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(\n        this.updateAnimations_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n   */\n  calculateCenterRotate(rotation, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n    return center;\n  }\n\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n   */\n  calculateCenterZoom(resolution, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    const currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      const x =\n        anchor[0] -\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\n      const y =\n        anchor[1] -\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  }\n\n  /**\n   * Returns the current viewport size.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  getViewportSize_(rotation) {\n    const size = this.viewportSize_;\n    if (rotation) {\n      const w = size[0];\n      const h = size[1];\n      return [\n        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),\n        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),\n      ];\n    } else {\n      return size;\n    }\n  }\n\n  /**\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n   * to avoid performance hit and layout reflow.\n   * This should be done on map size change.\n   * Note: the constraints are not resolved during an animation to avoid stopping it\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\n   */\n  setViewportSize(size) {\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  }\n\n  /**\n   * Get the view center.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  getCenter() {\n    const center = this.getCenterInternal();\n    if (!center) {\n      return center;\n    }\n    return toUserCoordinate(center, this.getProjection());\n  }\n\n  /**\n   * Get the view center without transforming to user projection.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   */\n  getCenterInternal() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(ViewProperty.CENTER)\n    );\n  }\n\n  /**\n   * @return {Constraints} Constraints.\n   */\n  getConstraints() {\n    return this.constraints_;\n  }\n\n  /**\n   * @return {boolean} Resolution constraint is set\n   */\n  getConstrainResolution() {\n    return this.get('constrainResolution');\n  }\n\n  /**\n   * @param {Array<number>} [hints] Destination array.\n   * @return {Array<number>} Hint.\n   */\n  getHints(hints) {\n    if (hints !== undefined) {\n      hints[0] = this.hints_[0];\n      hints[1] = this.hints_[1];\n      return hints;\n    } else {\n      return this.hints_.slice();\n    }\n  }\n\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided, the size\n   * of the map that uses this view will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   * @api\n   */\n  calculateExtent(size) {\n    const extent = this.calculateExtentInternal(size);\n    return toUserExtent(extent, this.getProjection());\n  }\n\n  /**\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\n   * the map's last known viewport size will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  calculateExtentInternal(size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    assert(center, 1); // The view center is not defined\n    const resolution = /** @type {!number} */ (this.getResolution());\n    assert(resolution !== undefined, 2); // The view resolution is not defined\n    const rotation = /** @type {!number} */ (this.getRotation());\n    assert(rotation !== undefined, 3); // The view rotation is not defined\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  }\n\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  getMaxResolution() {\n    return this.maxResolution_;\n  }\n\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  getMinResolution() {\n    return this.minResolution_;\n  }\n\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.minResolution_)\n    );\n  }\n\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  }\n\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  }\n\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  }\n\n  /**\n   * Set whether the view should allow intermediary zoom levels.\n   * @param {boolean} enabled Whether the resolution is constrained.\n   * @api\n   */\n  setConstrainResolution(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\n  }\n\n  /**\n   * Get the view projection.\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n   * @api\n   */\n  getProjection() {\n    return this.projection_;\n  }\n\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  getResolution() {\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n  }\n\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  getResolutionForExtent(extent, size) {\n    return this.getResolutionForExtentInternal(\n      fromUserExtent(extent, this.getProjection()),\n      size\n    );\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   */\n  getResolutionForExtentInternal(extent, size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const xResolution = getWidth(extent) / size[0];\n    const yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  }\n\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  getResolutionForValueFunction(power) {\n    power = power || 2;\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        const resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  }\n\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  getRotation() {\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n  }\n\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  getValueForResolutionFunction(power) {\n    const logPower = Math.log(power || 2);\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / logPower;\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        const value = Math.log(maxResolution / resolution) / logPower / max;\n        return value;\n      }\n    );\n  }\n\n  /**\n   * Returns the size of the viewport minus padding.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n   */\n  getViewportSizeMinusPadding_(rotation) {\n    let size = this.getViewportSize_(rotation);\n    const padding = this.padding_;\n    if (padding) {\n      size = [\n        size[0] - padding[1] - padding[3],\n        size[1] - padding[0] - padding[2],\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * @return {State} View state.\n   */\n  getState() {\n    const projection = this.getProjection();\n    const resolution = this.getResolution();\n    const rotation = this.getRotation();\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    const padding = this.padding_;\n    if (padding) {\n      const reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(\n        center,\n        this.getViewportSize_(),\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation\n      );\n    }\n    return {\n      center: center.slice(0),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation: rotation,\n      zoom: this.getZoom(),\n    };\n  }\n\n  /**\n   * Get the current zoom level. This method may return non-integer zoom levels\n   * if the view does not constrain the resolution, or if an interaction or\n   * animation is underway.\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  getZoom() {\n    let zoom;\n    const resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  }\n\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  getZoomForResolution(resolution) {\n    let offset = this.minZoom_ || 0;\n    let max, zoomFactor;\n    if (this.resolutions_) {\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  }\n\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  getResolutionForZoom(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n      const baseLevel = clamp(\n        Math.floor(zoom),\n        0,\n        this.resolutions_.length - 2\n      );\n      const zoomFactor =\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return (\n        this.resolutions_[baseLevel] /\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\n      );\n    } else {\n      return (\n        this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\n      );\n    }\n  }\n\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions} [options] Options.\n   * @api\n   */\n  fit(geometryOrExtent, options) {\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n    let geometry;\n    assert(\n      Array.isArray(geometryOrExtent) ||\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\n          'function',\n      24\n    ); // Invalid extent or geometry provided as `geometry`\n    if (Array.isArray(geometryOrExtent)) {\n      assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = polygonFromExtent(extent);\n    } else if (geometryOrExtent.getType() === 'Circle') {\n      const extent = fromUserExtent(\n        geometryOrExtent.getExtent(),\n        this.getProjection()\n      );\n      geometry = polygonFromExtent(extent);\n      geometry.rotate(this.getRotation(), getCenter(extent));\n    } else {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n          geometryOrExtent\n            .clone()\n            .transform(userProjection, this.getProjection())\n        );\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n\n    this.fitInternal(geometry, options);\n  }\n\n  /**\n   * Calculate rotated extent\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n   */\n  rotatedExtentForGeometry(geometry) {\n    const rotation = this.getRotation();\n    const cosAngle = Math.cos(rotation);\n    const sinAngle = Math.sin(-rotation);\n    const coords = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    let minRotX = +Infinity;\n    let minRotY = +Infinity;\n    let maxRotX = -Infinity;\n    let maxRotY = -Infinity;\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  }\n\n  /**\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @param {FitOptions} [options] Options.\n   */\n  fitInternal(geometry, options) {\n    options = options || {};\n    let size = options.size;\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n    const padding =\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    const nearest = options.nearest !== undefined ? options.nearest : false;\n    let minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\n\n    // calculate resolution\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n      size[0] - padding[1] - padding[3],\n      size[1] - padding[0] - padding[2],\n    ]);\n    resolution = isNaN(resolution)\n      ? minResolution\n      : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n\n    // calculate center\n    const rotation = this.getRotation();\n    const sinAngle = Math.sin(rotation);\n    const cosAngle = Math.cos(rotation);\n    const centerRot = getCenter(rotatedExtent);\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\n    const callback = options.callback ? options.callback : VOID;\n\n    if (options.duration !== undefined) {\n      this.animateInternal(\n        {\n          resolution: resolution,\n          center: center,\n          duration: options.duration,\n          easing: options.easing,\n        },\n        callback\n      );\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  }\n\n  /**\n   * Center on coordinate and view position.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   * @api\n   */\n  centerOn(coordinate, size, position) {\n    this.centerOnInternal(\n      fromUserCoordinate(coordinate, this.getProjection()),\n      size,\n      position\n    );\n  }\n\n  /**\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   */\n  centerOnInternal(coordinate, size, position) {\n    this.setCenterInternal(\n      calculateCenterOn(\n        coordinate,\n        size,\n        position,\n        this.getResolution(),\n        this.getRotation()\n      )\n    );\n  }\n\n  /**\n   * Calculates the shift between map and viewport center.\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {import(\"./size.js\").Size} size Size.\n   * @return {Array<number>|undefined} Center shift.\n   */\n  calculateCenterShift(center, resolution, rotation, size) {\n    let centerShift;\n    const padding = this.padding_;\n    if (padding && center) {\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      const shiftedCenter = calculateCenterOn(\n        center,\n        size,\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation\n      );\n      centerShift = [\n        center[0] - shiftedCenter[0],\n        center[1] - shiftedCenter[1],\n      ];\n    }\n    return centerShift;\n  }\n\n  /**\n   * @return {boolean} Is defined.\n   */\n  isDef() {\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   * @api\n   */\n  adjustCenter(deltaCoordinates) {\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   */\n  adjustCenterInternal(deltaCoordinates) {\n    const center = this.targetCenter_;\n    this.setCenterInternal([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustResolution(ratio, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  adjustResolutionInternal(ratio, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const size = this.getViewportSize_(this.getRotation());\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_ * ratio,\n      0,\n      size,\n      isMoving\n    );\n\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\n    }\n\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom level.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustZoom(delta, anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\n  }\n\n  /**\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   * @api\n   */\n  adjustRotation(delta, anchor) {\n    if (anchor) {\n      anchor = fromUserCoordinate(anchor, this.getProjection());\n    }\n    this.adjustRotationInternal(delta, anchor);\n  }\n\n  /**\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   */\n  adjustRotationInternal(delta, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_ + delta,\n      isMoving\n    );\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\n    }\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the center of the current view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  setCenter(center) {\n    this.setCenterInternal(\n      center ? fromUserCoordinate(center, this.getProjection()) : center\n    );\n  }\n\n  /**\n   * Set the center using the view projection (not the user projection).\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   */\n  setCenterInternal(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  }\n\n  /**\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  }\n\n  /**\n   * Set the resolution for this view. Any resolution constraint will apply.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  setResolution(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the rotation for this view. Any rotation constraint will apply.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  setRotation(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  }\n\n  /**\n   * Recompute rotation/resolution/center based on target values.\n   * Note: we have to compute rotation first, then resolution and center considering that\n   * parameters can influence one another in case a view extent constraint is present.\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\n   * @private\n   */\n  applyTargetState_(doNotCancelAnims, forceMoving) {\n    const isMoving =\n      this.getAnimating() || this.getInteracting() || forceMoving;\n\n    // compute rotation\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_,\n      isMoving\n    );\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      0,\n      size,\n      isMoving\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      isMoving,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size\n      )\n    );\n\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set('zoom', this.getZoom(), true);\n    }\n    if (\n      !newCenter ||\n      !this.get(ViewProperty.CENTER) ||\n      !equals(this.get(ViewProperty.CENTER), newCenter)\n    ) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n\n    if (this.getAnimating() && !doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n    this.cancelAnchor_ = undefined;\n  }\n\n  /**\n   * If any constraints need to be applied, an animation will be triggered.\n   * This is typically done on interaction end.\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\n   * without animation.\n   * @param {number} [duration] The animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  resolveConstraints(duration, resolutionDirection, anchor) {\n    duration = duration !== undefined ? duration : 200;\n    const direction = resolutionDirection || 0;\n\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      direction,\n      size\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      false,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size\n      )\n    );\n\n    if (duration === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n    this.cancelAnchor_ = undefined;\n\n    if (\n      this.getResolution() !== newResolution ||\n      this.getRotation() !== newRotation ||\n      !this.getCenterInternal() ||\n      !equals(this.getCenterInternal(), newCenter)\n    ) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration,\n        easing: easeOut,\n        anchor: anchor,\n      });\n    }\n  }\n\n  /**\n   * Notify the View that an interaction has started.\n   * The view state will be resolved to a stable one if needed\n   * (depending on its constraints).\n   * @api\n   */\n  beginInteraction() {\n    this.resolveConstraints(0);\n\n    this.setHint(ViewHint.INTERACTING, 1);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  endInteraction(duration, resolutionDirection, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  endInteractionInternal(duration, resolutionDirection, anchor) {\n    this.setHint(ViewHint.INTERACTING, -1);\n\n    this.resolveConstraints(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Get a valid position for the view center according to the current constraints.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\n   * This is useful to guess a valid center position at a different zoom level.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n   */\n  getConstrainedCenter(targetCenter, targetResolution) {\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(\n      targetCenter,\n      targetResolution || this.getResolution(),\n      size\n    );\n  }\n\n  /**\n   * Get a valid zoom level according to the current view constraints.\n   * @param {number|undefined} targetZoom Target zoom.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid zoom level.\n   */\n  getConstrainedZoom(targetZoom, direction) {\n    const targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(\n      this.getConstrainedResolution(targetRes, direction)\n    );\n  }\n\n  /**\n   * Get a valid resolution according to the current view constraints.\n   * @param {number|undefined} targetResolution Target resolution.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid resolution.\n   */\n  getConstrainedResolution(targetResolution, direction) {\n    direction = direction || 0;\n    const size = this.getViewportSize_(this.getRotation());\n\n    return this.constraints_.resolution(targetResolution, direction, size);\n  }\n}\n\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    const smooth =\n      options.smoothExtentConstraint !== undefined\n        ? options.smoothExtentConstraint\n        : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    const extent = projection.getExtent().slice();\n    extent[0] = -Infinity;\n    extent[2] = Infinity;\n    return createExtent(extent, false, false);\n  }\n\n  return centerNone;\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n  let resolutionConstraint;\n  let maxResolution;\n  let minResolution;\n\n  // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n  const defaultMaxZoom = 28;\n  const defaultZoomFactor = 2;\n\n  let minZoom =\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n\n  let maxZoom =\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n\n  const zoomFactor =\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  const multiWorld =\n    options.multiWorld !== undefined ? options.multiWorld : false;\n\n  const smooth =\n    options.smoothResolutionConstraint !== undefined\n      ? options.smoothResolutionConstraint\n      : true;\n\n  const showFullExtent =\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  const projExtent = projection.getExtent();\n  let constrainOnlyCenter = options.constrainOnlyCenter;\n  let extent = options.extent;\n  if (!multiWorld && !extent && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent = projExtent;\n  }\n\n  if (options.resolutions !== undefined) {\n    const resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution =\n      resolutions[maxZoom] !== undefined\n        ? resolutions[maxZoom]\n        : resolutions[resolutions.length - 1];\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(\n        resolutions,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    }\n  } else {\n    // calculate the default min and max resolution\n    const size = !projExtent\n      ? // use an extent that can fit the whole world if need be\n        (360 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\n\n    const defaultMaxResolution =\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n\n    const defaultMinResolution =\n      defaultMaxResolution /\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n\n    // user provided maxResolution takes precedence\n    maxResolution = options.maxResolution;\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n\n    // user provided minResolution takes precedence\n    minResolution = options.minResolution;\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n\n    // given discrete zoom levels, minResolution may be different than provided\n    maxZoom =\n      minZoom +\n      Math.floor(\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor)\n      );\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(\n        zoomFactor,\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    }\n  }\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor,\n  };\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n  const enableRotation =\n    options.enableRotation !== undefined ? options.enableRotation : true;\n  if (enableRotation) {\n    const constrainRotation = options.constrainRotation;\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return rotationNone;\n    } else if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    } else {\n      return rotationNone;\n    }\n  } else {\n    return disable;\n  }\n}\n\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n  // calculate rotated position\n  const cosAngle = Math.cos(-rotation);\n  let sinAngle = Math.sin(-rotation);\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position[0]) * resolution;\n  rotY += (position[1] - size[1] / 2) * resolution;\n\n  // go back to original angle\n  sinAngle = -sinAngle; // go back to original rotation\n  const centerX = rotX * cosAngle - rotY * sinAngle;\n  const centerY = rotY * cosAngle + rotX * sinAngle;\n\n  return [centerX, centerY];\n}\n\nexport default View;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAP,MAAuB,aAAvB;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,SAAQC,iBAAR,QAAgC,sBAAhC;AACA,SACEC,eADF,EAEEC,gBAFF,EAGEC,wBAHF,EAIEC,kBAJF,EAKEC,cALF,EAMEC,iBANF,EAOEC,gBAPF,EAQEC,YARF,QASO,WATP;AAUA,SAAQC,IAAR,QAAmB,gBAAnB;AACA,SACEC,GAAG,IAAIC,aADT,EAEEC,MAAM,IAAIC,gBAFZ,EAGED,MAHF,EAIEE,MAAM,IAAIC,gBAJZ,QAKO,iBALP;AAMA,SAAQC,MAAR,QAAqB,cAArB;AACA,SAAQC,IAAI,IAAIC,UAAhB,EAA4BC,YAA5B,QAA+C,uBAA/C;AACA,SAAQC,KAAR,EAAeC,MAAf,QAA4B,WAA5B;AACA,SACEC,sBADF,EAEEC,iBAFF,EAGEC,uBAHF,QAIO,2BAJP;AAKA,SACEC,aADF,EAEEC,gBAFF,EAGEC,OAHF,EAIEV,IAAI,IAAIW,YAJV,QAKO,yBALP;AAMA,SAAQC,OAAR,EAAiBC,QAAjB,QAAgC,aAAhC;AACA,SACEC,SADF,EAEEC,iBAFF,EAGEC,SAHF,EAIEC,QAJF,EAKEC,OALF,QAMO,aANP;AAOA,SAAQC,iBAAR,QAAgC,YAAhC;AACA,SAAQC,UAAU,IAAIC,iBAAtB,QAA8C,mBAA9C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAG,CAAzB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,IAAN,SAAmB3C,UAAnB,CAA8B;EAC5B;AACF;AACA;EACE4C,WAAW,CAACC,OAAD,EAAU;IACnB;IAEA;AACJ;AACA;;IACI,KAAKC,EAAL;IAEA;AACJ;AACA;;IACI,KAAKC,IAAL;IAEA;AACJ;AACA;;IACI,KAAKC,EAAL;IAEAH,OAAO,GAAGI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,OAAlB,CAAV;IAEA;AACJ;AACA;AACA;;IACI,KAAKM,MAAL,GAAc,CAAC,CAAD,EAAI,CAAJ,CAAd;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,WAAL,GAAm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"},"metadata":{},"sourceType":"module"}