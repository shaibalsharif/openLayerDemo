{"ast":null,"code":"/**\n * @module ol/geom/flat/intersectsextent\n */\nimport { containsExtent, createEmpty, extendFlatCoordinates, intersects, intersectsSegment } from '../../extent.js';\nimport { forEach as forEachSegment } from './segments.js';\nimport { linearRingContainsExtent, linearRingContainsXY } from './contains.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nexport function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n  const coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n\n  return forEachSegment(flatCoordinates, offset, end, stride,\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n   * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n   * @return {boolean} `true` if the segment and the extent intersect,\n   *     `false` otherwise.\n   */\n  function (point1, point2) {\n    return intersectsSegment(extent, point1, point2);\n  });\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nexport function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {\n      return true;\n    }\n\n    offset = ends[i];\n  }\n\n  return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nexport function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n    return true;\n  }\n\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n    return true;\n  }\n\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n    return true;\n  }\n\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nexport function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n\n  if (ends.length === 1) {\n    return true;\n  }\n\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nexport function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n\n    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {\n      return true;\n    }\n\n    offset = ends[ends.length - 1];\n  }\n\n  return false;\n}","map":{"version":3,"names":["containsExtent","createEmpty","extendFlatCoordinates","intersects","intersectsSegment","forEach","forEachSegment","linearRingContainsExtent","linearRingContainsXY","intersectsLineString","flatCoordinates","offset","end","stride","extent","coordinatesExtent","point1","point2","intersectsLineStringArray","ends","i","ii","length","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","endss"],"sources":["D:/Work/Learning/demo/node_modules/ol/geom/flat/intersectsextent.js"],"sourcesContent":["/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  containsExtent,\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {forEach as forEachSegment} from './segments.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const coordinatesExtent = extendFlatCoordinates(\n    createEmpty(),\n    flatCoordinates,\n    offset,\n    end,\n    stride\n  );\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    }\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}