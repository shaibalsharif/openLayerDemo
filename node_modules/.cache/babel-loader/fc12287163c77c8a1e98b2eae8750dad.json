{"ast":null,"code":"/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport { PROJECTIONS as EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326 } from './proj/epsg3857.js';\nimport { PROJECTIONS as EPSG4326_PROJECTIONS } from './proj/epsg4326.js';\nimport { METERS_PER_UNIT } from './proj/Units.js';\nimport { add as addProj, clear as clearProj, get as getProj } from './proj/projections.js';\nimport { add as addTransformFunc, clear as clearTransformFuncs, get as getTransformFunc } from './proj/transforms.js';\nimport { applyTransform, getWidth } from './extent.js';\nimport { clamp, modulo } from './math.js';\nimport { equals, getWorldsAway } from './coordinate.js';\nimport { getDistance } from './sphere.js';\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\nexport { METERS_PER_UNIT };\nexport { Projection };\nlet showCoordinateWarning = true;\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\n\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n\nexport function cloneTransform(input, output, dimension) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n\n    output = output;\n  } else {\n    output = input.slice();\n  }\n\n  return output;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\n\nexport function identityTransform(input, output, dimension) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n\n    input = output;\n  }\n\n  return input;\n}\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\n\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n/**\n * @param {Array<Projection>} projections Projections.\n */\n\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\n\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string' ? getProj(\n  /** @type {string} */\n  projectionLike) :\n  /** @type {Projection} */\n  projectionLike || null;\n}\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\n\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n\n  if (getter) {\n    pointResolution = getter(resolution, point);\n\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n\n      if (metersPerUnit) {\n        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n\n    if (projUnits == 'degrees' && !units || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));\n\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n\n      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();\n\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n\n  return pointResolution;\n}\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\n\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n\nexport function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n/**\n * Clear all cached projections and transforms.\n */\n\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\n\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return get(projection);\n  } else {\n    return (\n      /** @type {Projection} */\n      projection\n    );\n  }\n}\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\n\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n\n      return output;\n    }\n  );\n}\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\n\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(sourceProj, destProj, createTransformFromCoordinateTransform(forward));\n  addTransformFunc(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));\n}\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\n\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(coordinate, 'EPSG:4326', projection !== undefined ? projection : 'EPSG:3857');\n}\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(coordinate, projection !== undefined ? projection : 'EPSG:3857', 'EPSG:4326');\n  const lon = lonLat[0];\n\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n\n  return lonLat;\n}\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    const transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n  }\n}\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\n\nexport function getTransformFromProjections(sourceProjection, destinationProjection) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n\n  return transformFunc;\n}\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\n\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\n\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\n\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\n\nexport function transformWithProjections(point, sourceProjection, destinationProjection) {\n  const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);\n  return transformFunc(point);\n}\n/**\n * @type {Projection|null}\n */\n\nlet userProjection = null;\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\n\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n/**\n * Clear the user projection if set.\n * @api\n */\n\nexport function clearUserProjection() {\n  userProjection = null;\n}\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\n\nexport function getUserProjection() {\n  return userProjection;\n}\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API\n * methods except for those interacting with tile grids.\n * @api\n */\n\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\n\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n\n  return transform(coordinate, sourceProjection, userProjection);\n}\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\n\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (showCoordinateWarning && !equals(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {\n      showCoordinateWarning = false; // eslint-disable-next-line no-console\n\n      console.warn('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');\n    }\n\n    return coordinate;\n  }\n\n  return transform(coordinate, userProjection, destProjection);\n}\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\n\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\n\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n\n  return transformExtent(extent, userProjection, destProjection);\n}\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\n\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n\n  const sourceUnits = get(sourceProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[sourceUnits] / METERS_PER_UNIT[userUnits] : resolution;\n}\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\n\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n\n  const sourceUnits = get(destProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[userUnits] / METERS_PER_UNIT[sourceUnits] : resolution;\n}\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destiation).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destiation).\n */\n\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n\n    return transformed;\n  };\n}\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\n\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n\n  addEquivalentTransforms(EPSG4326_PROJECTIONS, EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326);\n}\naddCommon();","map":{"version":3,"names":["Projection","PROJECTIONS","EPSG3857_PROJECTIONS","fromEPSG4326","toEPSG4326","EPSG4326_PROJECTIONS","METERS_PER_UNIT","add","addProj","clear","clearProj","get","getProj","addTransformFunc","clearTransformFuncs","getTransformFunc","applyTransform","getWidth","clamp","modulo","equals","getWorldsAway","getDistance","showCoordinateWarning","disableCoordinateWarning","disable","hide","undefined","cloneTransform","input","output","dimension","i","ii","length","slice","identityTransform","addProjection","projection","getCode","addProjections","projections","forEach","projectionLike","getPointResolution","resolution","point","units","pointResolution","getter","getPointResolutionFunc","getUnits","metersPerUnit","getMetersPerUnit","projUnits","getTransformFromProjections","vertices","width","height","addEquivalentProjections","source","destination","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","clearAllProjections","createProjection","defaultCode","createTransformFromCoordinateTransform","coordTransform","Array","pointLength","j","jj","addCoordinateTransforms","forward","inverse","sourceProj","destProj","fromLonLat","coordinate","transform","toLonLat","lonLat","lon","equivalent","equalUnits","transformFunc","sourceProjection","destinationProjection","sourceCode","destinationCode","getTransform","transformExtent","extent","stops","transformWithProjections","userProjection","setUserProjection","clearUserProjection","getUserProjection","useGeographic","toUserCoordinate","fromUserCoordinate","destProjection","console","warn","toUserExtent","fromUserExtent","toUserResolution","sourceUnits","userUnits","fromUserResolution","createSafeCoordinateTransform","coord","transformed","worldsAway","canWrapX","sourceExtent","getExtent","sourceExtentWidth","addCommon"],"sources":["D:/Work/Learning/demo/node_modules/ol/proj.js"],"sourcesContent":["/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport {\n  PROJECTIONS as EPSG3857_PROJECTIONS,\n  fromEPSG4326,\n  toEPSG4326,\n} from './proj/epsg3857.js';\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\nimport {METERS_PER_UNIT} from './proj/Units.js';\nimport {\n  add as addProj,\n  clear as clearProj,\n  get as getProj,\n} from './proj/projections.js';\nimport {\n  add as addTransformFunc,\n  clear as clearTransformFuncs,\n  get as getTransformFunc,\n} from './proj/transforms.js';\nimport {applyTransform, getWidth} from './extent.js';\nimport {clamp, modulo} from './math.js';\nimport {equals, getWorldsAway} from './coordinate.js';\nimport {getDistance} from './sphere.js';\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\nexport {METERS_PER_UNIT};\n\nexport {Projection};\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, output, dimension) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, output, dimension) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string'\n    ? getProj(/** @type {string} */ (projectionLike))\n    : /** @type {Projection} */ (projectionLike) || null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get('EPSG:4326')\n      );\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return get(projection);\n  } else {\n    return /** @type {Projection} */ (projection);\n  }\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward)\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse)\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    'EPSG:4326',\n    projection !== undefined ? projection : 'EPSG:3857'\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : 'EPSG:3857',\n    'EPSG:4326'\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    const transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n  }\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(\n  sourceProjection,\n  destinationProjection\n) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API\n * methods except for those interacting with tile grids.\n * @api\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !equals(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.'\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(sourceProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[sourceUnits]) / METERS_PER_UNIT[userUnits]\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(destProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[userUnits]) / METERS_PER_UNIT[sourceUnits]\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destiation).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destiation).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    EPSG4326_PROJECTIONS,\n    EPSG3857_PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326\n  );\n}\n\naddCommon();\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,UAAP,MAAuB,sBAAvB;AACA,SACEC,WAAW,IAAIC,oBADjB,EAEEC,YAFF,EAGEC,UAHF,QAIO,oBAJP;AAKA,SAAQH,WAAW,IAAII,oBAAvB,QAAkD,oBAAlD;AACA,SAAQC,eAAR,QAA8B,iBAA9B;AACA,SACEC,GAAG,IAAIC,OADT,EAEEC,KAAK,IAAIC,SAFX,EAGEC,GAAG,IAAIC,OAHT,QAIO,uBAJP;AAKA,SACEL,GAAG,IAAIM,gBADT,EAEEJ,KAAK,IAAIK,mBAFX,EAGEH,GAAG,IAAII,gBAHT,QAIO,sBAJP;AAKA,SAAQC,cAAR,EAAwBC,QAAxB,QAAuC,aAAvC;AACA,SAAQC,KAAR,EAAeC,MAAf,QAA4B,WAA5B;AACA,SAAQC,MAAR,EAAgBC,aAAhB,QAAoC,iBAApC;AACA,SAAQC,WAAR,QAA0B,aAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQhB,eAAR;AAEA,SAAQN,UAAR;AAEA,IAAIuB,qBAAqB,GAAG,IAA5B;AAEA;AACA;AACA;;AACA,OAAO,SAASC,wBAAT,CAAkCC,OAAlC,EAA2C;EAChD,MAAMC,IAAI,GAAGD,OAAO,KAAKE,SAAZ,GAAwB,IAAxB,GAA+BF,OAA5C;EACAF,qBAAqB,GAAG,CAACG,IAAzB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,cAAT,CAAwBC,KAAxB,EAA+BC,MAA/B,EAAuCC,SAAvC,EAAkD;EACvD,IAAID,MAAM,KAAKH,SAAf,EAA0B;IACxB,KAAK,IAAIK,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,KAAK,CAACK,MAA3B,EAAmCF,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;MAC9CF,MAAM,CAACE,CAAD,CAAN,GAAYH,KAAK,CAACG,CAAD,CAAjB;IACD;;IACDF,MAAM,GAAGA,MAAT;EACD,CALD,MAKO;IACLA,MAAM,GAAGD,KAAK,CAACM,KAAN,EAAT;EACD;;EACD,OAAOL,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,iBAAT,CAA2BP,KAA3B,EAAkCC,MAAlC,EAA0CC,SAA1C,EAAqD;EAC1D,IAAID,MAAM,KAAKH,SAAX,IAAwBE,KAAK,KAAKC,MAAtC,EAA8C;IAC5C,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,KAAK,CAACK,MAA3B,EAAmCF,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;MAC9CF,MAAM,CAACE,CAAD,CAAN,GAAYH,KAAK,CAACG,CAAD,CAAjB;IACD;;IACDH,KAAK,GAAGC,MAAR;EACD;;EACD,OAAOD,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASQ,aAAT,CAAuBC,UAAvB,EAAmC;EACxC9B,OAAO,CAAC8B,UAAU,CAACC,OAAX,EAAD,EAAuBD,UAAvB,CAAP;EACAzB,gBAAgB,CAACyB,UAAD,EAAaA,UAAb,EAAyBV,cAAzB,CAAhB;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASY,cAAT,CAAwBC,WAAxB,EAAqC;EAC1CA,WAAW,CAACC,OAAZ,CAAoBL,aAApB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS1B,GAAT,CAAagC,cAAb,EAA6B;EAClC,OAAO,OAAOA,cAAP,KAA0B,QAA1B,GACH/B,OAAO;EAAC;EAAuB+B,cAAxB,CADJ;EAEH;EAA2BA,cAAD,IAAoB,IAFlD;AAGD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,kBAAT,CAA4BN,UAA5B,EAAwCO,UAAxC,EAAoDC,KAApD,EAA2DC,KAA3D,EAAkE;EACvET,UAAU,GAAG3B,GAAG,CAAC2B,UAAD,CAAhB;EACA,IAAIU,eAAJ;EACA,MAAMC,MAAM,GAAGX,UAAU,CAACY,sBAAX,EAAf;;EACA,IAAID,MAAJ,EAAY;IACVD,eAAe,GAAGC,MAAM,CAACJ,UAAD,EAAaC,KAAb,CAAxB;;IACA,IAAIC,KAAK,IAAIA,KAAK,KAAKT,UAAU,CAACa,QAAX,EAAvB,EAA8C;MAC5C,MAAMC,aAAa,GAAGd,UAAU,CAACe,gBAAX,EAAtB;;MACA,IAAID,aAAJ,EAAmB;QACjBJ,eAAe,GACZA,eAAe,GAAGI,aAAnB,GAAoC9C,eAAe,CAACyC,KAAD,CADrD;MAED;IACF;EACF,CATD,MASO;IACL,MAAMO,SAAS,GAAGhB,UAAU,CAACa,QAAX,EAAlB;;IACA,IAAKG,SAAS,IAAI,SAAb,IAA0B,CAACP,KAA5B,IAAsCA,KAAK,IAAI,SAAnD,EAA8D;MAC5DC,eAAe,GAAGH,UAAlB;IACD,CAFD,MAEO;MACL;MACA;MACA;MACA,MAAMzC,UAAU,GAAGmD,2BAA2B,CAC5CjB,UAD4C,EAE5C3B,GAAG,CAAC,WAAD,CAFyC,CAA9C;;MAIA,IAAIP,UAAU,KAAKgC,iBAAf,IAAoCkB,SAAS,KAAK,SAAtD,EAAiE;QAC/D;QACAN,eAAe,GAAGH,UAAU,GAAGP,UAAU,CAACe,gBAAX,EAA/B;MACD,CAHD,MAGO;QACL,IAAIG,QAAQ,GAAG,CACbV,KAAK,CAAC,CAAD,CAAL,GAAWD,UAAU,GAAG,CADX,EAEbC,KAAK,CAAC,CAAD,CAFQ,EAGbA,KAAK,CAAC,CAAD,CAAL,GAAWD,UAAU,GAAG,CAHX,EAIbC,KAAK,CAAC,CAAD,CAJQ,EAKbA,KAAK,CAAC,CAAD,CALQ,EAMbA,KAAK,CAAC,CAAD,CAAL,GAAWD,UAAU,GAAG,CANX,EAObC,KAAK,CAAC,CAAD,CAPQ,EAQbA,KAAK,CAAC,CAAD,CAAL,GAAWD,UAAU,GAAG,CARX,CAAf;QAUAW,QAAQ,GAAGpD,UAAU,CAACoD,QAAD,EAAWA,QAAX,EAAqB,CAArB,CAArB;QACA,MAAMC,KAAK,GAAGnC,WAAW,CAACkC,QAAQ,CAACrB,KAAT,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuBqB,QAAQ,CAACrB,KAAT,CAAe,CAAf,EAAkB,CAAlB,CAAvB,CAAzB;QACA,MAAMuB,MAAM,GAAGpC,WAAW,CAACkC,QAAQ,CAACrB,KAAT,CAAe,CAAf,EAAkB,CAAlB,CAAD,EAAuBqB,QAAQ,CAACrB,KAAT,CAAe,CAAf,EAAkB,CAAlB,CAAvB,CAA1B;QACAa,eAAe,GAAG,CAACS,KAAK,GAAGC,MAAT,IAAmB,CAArC;MACD;;MACD,MAAMN,aAAa,GAAGL,KAAK,GACvBzC,eAAe,CAACyC,KAAD,CADQ,GAEvBT,UAAU,CAACe,gBAAX,EAFJ;;MAGA,IAAID,aAAa,KAAKzB,SAAtB,EAAiC;QAC/BqB,eAAe,IAAII,aAAnB;MACD;IACF;EACF;;EACD,OAAOJ,eAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASW,wBAAT,CAAkClB,WAAlC,EAA+C;EACpDD,cAAc,CAACC,WAAD,CAAd;EACAA,WAAW,CAACC,OAAZ,CAAoB,UAAUkB,MAAV,EAAkB;IACpCnB,WAAW,CAACC,OAAZ,CAAoB,UAAUmB,WAAV,EAAuB;MACzC,IAAID,MAAM,KAAKC,WAAf,EAA4B;QAC1BhD,gBAAgB,CAAC+C,MAAD,EAASC,WAAT,EAAsBjC,cAAtB,CAAhB;MACD;IACF,CAJD;EAKD,CAND;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkC,uBAAT,CACLC,YADK,EAELC,YAFK,EAGLC,gBAHK,EAILC,gBAJK,EAKL;EACAH,YAAY,CAACrB,OAAb,CAAqB,UAAUyB,WAAV,EAAuB;IAC1CH,YAAY,CAACtB,OAAb,CAAqB,UAAU0B,WAAV,EAAuB;MAC1CvD,gBAAgB,CAACsD,WAAD,EAAcC,WAAd,EAA2BH,gBAA3B,CAAhB;MACApD,gBAAgB,CAACuD,WAAD,EAAcD,WAAd,EAA2BD,gBAA3B,CAAhB;IACD,CAHD;EAID,CALD;AAMD;AAED;AACA;AACA;;AACA,OAAO,SAASG,mBAAT,GAA+B;EACpC3D,SAAS;EACTI,mBAAmB;AACpB;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASwD,gBAAT,CAA0BhC,UAA1B,EAAsCiC,WAAtC,EAAmD;EACxD,IAAI,CAACjC,UAAL,EAAiB;IACf,OAAO3B,GAAG,CAAC4D,WAAD,CAAV;EACD,CAFD,MAEO,IAAI,OAAOjC,UAAP,KAAsB,QAA1B,EAAoC;IACzC,OAAO3B,GAAG,CAAC2B,UAAD,CAAV;EACD,CAFM,MAEA;IACL;MAAO;MAA2BA;IAAlC;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkC,sCAAT,CAAgDC,cAAhD,EAAgE;EACrE;IACE;AACJ;AACA;AACA;AACA;AACA;IACI,UAAU5C,KAAV,EAAiBC,MAAjB,EAAyBC,SAAzB,EAAoC;MAClC,MAAMG,MAAM,GAAGL,KAAK,CAACK,MAArB;MACAH,SAAS,GAAGA,SAAS,KAAKJ,SAAd,GAA0BI,SAA1B,GAAsC,CAAlD;MACAD,MAAM,GAAGA,MAAM,KAAKH,SAAX,GAAuBG,MAAvB,GAAgC,IAAI4C,KAAJ,CAAUxC,MAAV,CAAzC;;MACA,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,MAApB,EAA4BF,CAAC,IAAID,SAAjC,EAA4C;QAC1C,MAAMe,KAAK,GAAG2B,cAAc,CAAC5C,KAAK,CAACM,KAAN,CAAYH,CAAZ,EAAeA,CAAC,GAAGD,SAAnB,CAAD,CAA5B;QACA,MAAM4C,WAAW,GAAG7B,KAAK,CAACZ,MAA1B;;QACA,KAAK,IAAI0C,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAG9C,SAArB,EAAgC6C,CAAC,GAAGC,EAApC,EAAwC,EAAED,CAA1C,EAA6C;UAC3C9C,MAAM,CAACE,CAAC,GAAG4C,CAAL,CAAN,GAAgBA,CAAC,IAAID,WAAL,GAAmB9C,KAAK,CAACG,CAAC,GAAG4C,CAAL,CAAxB,GAAkC9B,KAAK,CAAC8B,CAAD,CAAvD;QACD;MACF;;MACD,OAAO9C,MAAP;IACD;EAnBH;AAqBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgD,uBAAT,CAAiClB,MAAjC,EAAyCC,WAAzC,EAAsDkB,OAAtD,EAA+DC,OAA/D,EAAwE;EAC7E,MAAMC,UAAU,GAAGtE,GAAG,CAACiD,MAAD,CAAtB;EACA,MAAMsB,QAAQ,GAAGvE,GAAG,CAACkD,WAAD,CAApB;EACAhD,gBAAgB,CACdoE,UADc,EAEdC,QAFc,EAGdV,sCAAsC,CAACO,OAAD,CAHxB,CAAhB;EAKAlE,gBAAgB,CACdqE,QADc,EAEdD,UAFc,EAGdT,sCAAsC,CAACQ,OAAD,CAHxB,CAAhB;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,UAAT,CAAoBC,UAApB,EAAgC9C,UAAhC,EAA4C;EACjDd,wBAAwB;EACxB,OAAO6D,SAAS,CACdD,UADc,EAEd,WAFc,EAGd9C,UAAU,KAAKX,SAAf,GAA2BW,UAA3B,GAAwC,WAH1B,CAAhB;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASgD,QAAT,CAAkBF,UAAlB,EAA8B9C,UAA9B,EAA0C;EAC/C,MAAMiD,MAAM,GAAGF,SAAS,CACtBD,UADsB,EAEtB9C,UAAU,KAAKX,SAAf,GAA2BW,UAA3B,GAAwC,WAFlB,EAGtB,WAHsB,CAAxB;EAKA,MAAMkD,GAAG,GAAGD,MAAM,CAAC,CAAD,CAAlB;;EACA,IAAIC,GAAG,GAAG,CAAC,GAAP,IAAcA,GAAG,GAAG,GAAxB,EAA6B;IAC3BD,MAAM,CAAC,CAAD,CAAN,GAAYpE,MAAM,CAACqE,GAAG,GAAG,GAAP,EAAY,GAAZ,CAAN,GAAyB,GAArC;EACD;;EACD,OAAOD,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,UAAT,CAAoBtB,WAApB,EAAiCC,WAAjC,EAA8C;EACnD,IAAID,WAAW,KAAKC,WAApB,EAAiC;IAC/B,OAAO,IAAP;EACD;;EACD,MAAMsB,UAAU,GAAGvB,WAAW,CAAChB,QAAZ,OAA2BiB,WAAW,CAACjB,QAAZ,EAA9C;;EACA,IAAIgB,WAAW,CAAC5B,OAAZ,OAA0B6B,WAAW,CAAC7B,OAAZ,EAA9B,EAAqD;IACnD,OAAOmD,UAAP;EACD,CAFD,MAEO;IACL,MAAMC,aAAa,GAAGpC,2BAA2B,CAACY,WAAD,EAAcC,WAAd,CAAjD;IACA,OAAOuB,aAAa,KAAK/D,cAAlB,IAAoC8D,UAA3C;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASnC,2BAAT,CACLqC,gBADK,EAELC,qBAFK,EAGL;EACA,MAAMC,UAAU,GAAGF,gBAAgB,CAACrD,OAAjB,EAAnB;EACA,MAAMwD,eAAe,GAAGF,qBAAqB,CAACtD,OAAtB,EAAxB;EACA,IAAIoD,aAAa,GAAG5E,gBAAgB,CAAC+E,UAAD,EAAaC,eAAb,CAApC;;EACA,IAAI,CAACJ,aAAL,EAAoB;IAClBA,aAAa,GAAGvD,iBAAhB;EACD;;EACD,OAAOuD,aAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,YAAT,CAAsBpC,MAAtB,EAA8BC,WAA9B,EAA2C;EAChD,MAAM+B,gBAAgB,GAAGjF,GAAG,CAACiD,MAAD,CAA5B;EACA,MAAMiC,qBAAqB,GAAGlF,GAAG,CAACkD,WAAD,CAAjC;EACA,OAAON,2BAA2B,CAACqC,gBAAD,EAAmBC,qBAAnB,CAAlC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASR,SAAT,CAAmBD,UAAnB,EAA+BxB,MAA/B,EAAuCC,WAAvC,EAAoD;EACzD,MAAM8B,aAAa,GAAGK,YAAY,CAACpC,MAAD,EAASC,WAAT,CAAlC;EACA,OAAO8B,aAAa,CAACP,UAAD,EAAazD,SAAb,EAAwByD,UAAU,CAAClD,MAAnC,CAApB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS+D,eAAT,CAAyBC,MAAzB,EAAiCtC,MAAjC,EAAyCC,WAAzC,EAAsDsC,KAAtD,EAA6D;EAClE,MAAMR,aAAa,GAAGK,YAAY,CAACpC,MAAD,EAASC,WAAT,CAAlC;EACA,OAAO7C,cAAc,CAACkF,MAAD,EAASP,aAAT,EAAwBhE,SAAxB,EAAmCwE,KAAnC,CAArB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,wBAAT,CACLtD,KADK,EAEL8C,gBAFK,EAGLC,qBAHK,EAIL;EACA,MAAMF,aAAa,GAAGpC,2BAA2B,CAC/CqC,gBAD+C,EAE/CC,qBAF+C,CAAjD;EAIA,OAAOF,aAAa,CAAC7C,KAAD,CAApB;AACD;AAED;AACA;AACA;;AACA,IAAIuD,cAAc,GAAG,IAArB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,CAA2BhE,UAA3B,EAAuC;EAC5C+D,cAAc,GAAG1F,GAAG,CAAC2B,UAAD,CAApB;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASiE,mBAAT,GAA+B;EACpCF,cAAc,GAAG,IAAjB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,iBAAT,GAA6B;EAClC,OAAOH,cAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,aAAT,GAAyB;EAC9BH,iBAAiB,CAAC,WAAD,CAAjB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,gBAAT,CAA0BtB,UAA1B,EAAsCQ,gBAAtC,EAAwD;EAC7D,IAAI,CAACS,cAAL,EAAqB;IACnB,OAAOjB,UAAP;EACD;;EACD,OAAOC,SAAS,CAACD,UAAD,EAAaQ,gBAAb,EAA+BS,cAA/B,CAAhB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,kBAAT,CAA4BvB,UAA5B,EAAwCwB,cAAxC,EAAwD;EAC7D,IAAI,CAACP,cAAL,EAAqB;IACnB,IACE9E,qBAAqB,IACrB,CAACH,MAAM,CAACgE,UAAD,EAAa,CAAC,CAAD,EAAI,CAAJ,CAAb,CADP,IAEAA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAC,GAFlB,IAGAA,UAAU,CAAC,CAAD,CAAV,IAAiB,GAHjB,IAIAA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAC,EAJlB,IAKAA,UAAU,CAAC,CAAD,CAAV,IAAiB,EANnB,EAOE;MACA7D,qBAAqB,GAAG,KAAxB,CADA,CAEA;;MACAsF,OAAO,CAACC,IAAR,CACE,wFADF;IAGD;;IACD,OAAO1B,UAAP;EACD;;EACD,OAAOC,SAAS,CAACD,UAAD,EAAaiB,cAAb,EAA6BO,cAA7B,CAAhB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,YAAT,CAAsBb,MAAtB,EAA8BN,gBAA9B,EAAgD;EACrD,IAAI,CAACS,cAAL,EAAqB;IACnB,OAAOH,MAAP;EACD;;EACD,OAAOD,eAAe,CAACC,MAAD,EAASN,gBAAT,EAA2BS,cAA3B,CAAtB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASW,cAAT,CAAwBd,MAAxB,EAAgCU,cAAhC,EAAgD;EACrD,IAAI,CAACP,cAAL,EAAqB;IACnB,OAAOH,MAAP;EACD;;EACD,OAAOD,eAAe,CAACC,MAAD,EAASG,cAAT,EAAyBO,cAAzB,CAAtB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,gBAAT,CAA0BpE,UAA1B,EAAsC+C,gBAAtC,EAAwD;EAC7D,IAAI,CAACS,cAAL,EAAqB;IACnB,OAAOxD,UAAP;EACD;;EACD,MAAMqE,WAAW,GAAGvG,GAAG,CAACiF,gBAAD,CAAH,CAAsBzC,QAAtB,EAApB;EACA,MAAMgE,SAAS,GAAGd,cAAc,CAAClD,QAAf,EAAlB;EACA,OAAO+D,WAAW,IAAIC,SAAf,GACFtE,UAAU,GAAGvC,eAAe,CAAC4G,WAAD,CAA7B,GAA8C5G,eAAe,CAAC6G,SAAD,CAD1D,GAEHtE,UAFJ;AAGD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASuE,kBAAT,CAA4BvE,UAA5B,EAAwC+D,cAAxC,EAAwD;EAC7D,IAAI,CAACP,cAAL,EAAqB;IACnB,OAAOxD,UAAP;EACD;;EACD,MAAMqE,WAAW,GAAGvG,GAAG,CAACiG,cAAD,CAAH,CAAoBzD,QAApB,EAApB;EACA,MAAMgE,SAAS,GAAGd,cAAc,CAAClD,QAAf,EAAlB;EACA,OAAO+D,WAAW,IAAIC,SAAf,GACFtE,UAAU,GAAGvC,eAAe,CAAC6G,SAAD,CAA7B,GAA4C7G,eAAe,CAAC4G,WAAD,CADxD,GAEHrE,UAFJ;AAGD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASwE,6BAAT,CAAuCpC,UAAvC,EAAmDC,QAAnD,EAA6DG,SAA7D,EAAwE;EAC7E,OAAO,UAAUiC,KAAV,EAAiB;IACtB,IAAIC,WAAJ,EAAiBC,UAAjB;;IACA,IAAIvC,UAAU,CAACwC,QAAX,EAAJ,EAA2B;MACzB,MAAMC,YAAY,GAAGzC,UAAU,CAAC0C,SAAX,EAArB;MACA,MAAMC,iBAAiB,GAAG3G,QAAQ,CAACyG,YAAD,CAAlC;MACAJ,KAAK,GAAGA,KAAK,CAACnF,KAAN,CAAY,CAAZ,CAAR;MACAqF,UAAU,GAAGnG,aAAa,CAACiG,KAAD,EAAQrC,UAAR,EAAoB2C,iBAApB,CAA1B;;MACA,IAAIJ,UAAJ,EAAgB;QACd;QACAF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,GAAWE,UAAU,GAAGI,iBAAnC;MACD;;MACDN,KAAK,CAAC,CAAD,CAAL,GAAWpG,KAAK,CAACoG,KAAK,CAAC,CAAD,CAAN,EAAWI,YAAY,CAAC,CAAD,CAAvB,EAA4BA,YAAY,CAAC,CAAD,CAAxC,CAAhB;MACAJ,KAAK,CAAC,CAAD,CAAL,GAAWpG,KAAK,CAACoG,KAAK,CAAC,CAAD,CAAN,EAAWI,YAAY,CAAC,CAAD,CAAvB,EAA4BA,YAAY,CAAC,CAAD,CAAxC,CAAhB;MACAH,WAAW,GAAGlC,SAAS,CAACiC,KAAD,CAAvB;IACD,CAZD,MAYO;MACLC,WAAW,GAAGlC,SAAS,CAACiC,KAAD,CAAvB;IACD;;IACD,IAAIE,UAAU,IAAItC,QAAQ,CAACuC,QAAT,EAAlB,EAAuC;MACrC;MACAF,WAAW,CAAC,CAAD,CAAX,IAAkBC,UAAU,GAAGvG,QAAQ,CAACiE,QAAQ,CAACyC,SAAT,EAAD,CAAvC;IACD;;IACD,OAAOJ,WAAP;EACD,CAtBD;AAuBD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,SAAT,GAAqB;EAC1B;EACA;EACAlE,wBAAwB,CAACzD,oBAAD,CAAxB;EACAyD,wBAAwB,CAACtD,oBAAD,CAAxB,CAJ0B,CAK1B;EACA;;EACAyD,uBAAuB,CACrBzD,oBADqB,EAErBH,oBAFqB,EAGrBC,YAHqB,EAIrBC,UAJqB,CAAvB;AAMD;AAEDyH,SAAS"},"metadata":{},"sourceType":"module"}