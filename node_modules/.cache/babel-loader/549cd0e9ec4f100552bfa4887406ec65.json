{"ast":null,"code":"/**\n * @module ol/rotationconstraint\n */\nimport { toRadians } from './math.js';\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\n\nexport function disable(rotation) {\n  if (rotation !== undefined) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\n\nexport function none(rotation) {\n  if (rotation !== undefined) {\n    return rotation;\n  } else {\n    return undefined;\n  }\n}\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\n\nexport function createSnapToN(n) {\n  const theta = 2 * Math.PI / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\n        return rotation;\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} [tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\n\nexport function createSnapToZero(tolerance) {\n  tolerance = tolerance || toRadians(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        if (Math.abs(rotation) <= tolerance) {\n          return 0;\n        } else {\n          return rotation;\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"names":["toRadians","disable","rotation","undefined","none","createSnapToN","n","theta","Math","PI","isMoving","floor","createSnapToZero","tolerance","abs"],"sources":["D:/Work/Learning/demo/node_modules/ol/rotationconstraint.js"],"sourcesContent":["/**\n * @module ol/rotationconstraint\n */\nimport {toRadians} from './math.js';\n\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n  if (rotation !== undefined) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n  if (rotation !== undefined) {\n    return rotation;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n  const theta = (2 * Math.PI) / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\n        return rotation;\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} [tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(tolerance) {\n  tolerance = tolerance || toRadians(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        if (Math.abs(rotation) <= tolerance) {\n          return 0;\n        } else {\n          return rotation;\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,SAAR,QAAwB,WAAxB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,OAAT,CAAiBC,QAAjB,EAA2B;EAChC,IAAIA,QAAQ,KAAKC,SAAjB,EAA4B;IAC1B,OAAO,CAAP;EACD,CAFD,MAEO;IACL,OAAOA,SAAP;EACD;AACF;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASC,IAAT,CAAcF,QAAd,EAAwB;EAC7B,IAAIA,QAAQ,KAAKC,SAAjB,EAA4B;IAC1B,OAAOD,QAAP;EACD,CAFD,MAEO;IACL,OAAOC,SAAP;EACD;AACF;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASE,aAAT,CAAuBC,CAAvB,EAA0B;EAC/B,MAAMC,KAAK,GAAI,IAAIC,IAAI,CAACC,EAAV,GAAgBH,CAA9B;EACA;IACE;AACJ;AACA;AACA;AACA;IACI,UAAUJ,QAAV,EAAoBQ,QAApB,EAA8B;MAC5B,IAAIA,QAAJ,EAAc;QACZ,OAAOR,QAAP;MACD;;MAED,IAAIA,QAAQ,KAAKC,SAAjB,EAA4B;QAC1BD,QAAQ,GAAGM,IAAI,CAACG,KAAL,CAAWT,QAAQ,GAAGK,KAAX,GAAmB,GAA9B,IAAqCA,KAAhD;QACA,OAAOL,QAAP;MACD,CAHD,MAGO;QACL,OAAOC,SAAP;MACD;IACF;EAjBH;AAmBD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASS,gBAAT,CAA0BC,SAA1B,EAAqC;EAC1CA,SAAS,GAAGA,SAAS,IAAIb,SAAS,CAAC,CAAD,CAAlC;EACA;IACE;AACJ;AACA;AACA;AACA;IACI,UAAUE,QAAV,EAAoBQ,QAApB,EAA8B;MAC5B,IAAIA,QAAJ,EAAc;QACZ,OAAOR,QAAP;MACD;;MAED,IAAIA,QAAQ,KAAKC,SAAjB,EAA4B;QAC1B,IAAIK,IAAI,CAACM,GAAL,CAASZ,QAAT,KAAsBW,SAA1B,EAAqC;UACnC,OAAO,CAAP;QACD,CAFD,MAEO;UACL,OAAOX,QAAP;QACD;MACF,CAND,MAMO;QACL,OAAOC,SAAP;MACD;IACF;EApBH;AAsBD"},"metadata":{},"sourceType":"module"}