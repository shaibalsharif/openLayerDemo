{"ast":null,"code":"import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\n\nexport function createCanvasContext2D(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n\n  if (canvasPool && canvasPool.length) {\n    canvas = canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n\n  if (width) {\n    canvas.width = width;\n  }\n\n  if (height) {\n    canvas.height = height;\n  } //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n\n\n  return (\n    /** @type {CanvasRenderingContext2D} */\n    canvas.getContext('2d', settings)\n  );\n}\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\n\nexport function releaseCanvas(context) {\n  const canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\n\nexport function outerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n  return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\n\nexport function outerHeight(element) {\n  let height = element.offsetHeight;\n  const style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n  return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\n\nexport function replaceNode(newNode, oldNode) {\n  const parent = oldNode.parentNode;\n\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\n\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\n\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\n\nexport function replaceChildren(node, children) {\n  const oldChildren = node.childNodes;\n\n  for (let i = 0; true; ++i) {\n    const oldChild = oldChildren[i];\n    const newChild = children[i]; // check if our work is done\n\n    if (!oldChild && !newChild) {\n      break;\n    } // check if children match\n\n\n    if (oldChild === newChild) {\n      continue;\n    } // check if a new child needs to be added\n\n\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    } // check if an old child needs to be removed\n\n\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    } // reorder\n\n\n    node.insertBefore(newChild, oldChild);\n  }\n}","map":{"version":3,"names":["WORKER_OFFSCREEN_CANVAS","createCanvasContext2D","width","height","canvasPool","settings","canvas","length","shift","OffscreenCanvas","document","createElement","getContext","releaseCanvas","context","clearRect","outerWidth","element","offsetWidth","style","getComputedStyle","parseInt","marginLeft","marginRight","outerHeight","offsetHeight","marginTop","marginBottom","replaceNode","newNode","oldNode","parent","parentNode","replaceChild","removeNode","node","removeChild","removeChildren","lastChild","replaceChildren","children","oldChildren","childNodes","i","oldChild","newChild","appendChild","insertBefore"],"sources":["D:/Work/Learning/demo/node_modules/ol/dom.js"],"sourcesContent":["import {WORKER_OFFSCREEN_CANVAS} from './has.js';\n\n/**\n * @module ol/dom\n */\n\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {CanvasRenderingContext2D} */ (\n    canvas.getContext('2d', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n  const canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n\n  return width;\n}\n\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n  let height = element.offsetHeight;\n  const style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n\n  return height;\n}\n\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n  const parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n  const oldChildren = node.childNodes;\n\n  for (let i = 0; true; ++i) {\n    const oldChild = oldChildren[i];\n    const newChild = children[i];\n\n    // check if our work is done\n    if (!oldChild && !newChild) {\n      break;\n    }\n\n    // check if children match\n    if (oldChild === newChild) {\n      continue;\n    }\n\n    // check if a new child needs to be added\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    }\n\n    // check if an old child needs to be removed\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    }\n\n    // reorder\n    node.insertBefore(newChild, oldChild);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}