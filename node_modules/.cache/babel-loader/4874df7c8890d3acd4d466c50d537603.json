{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n\n    super.clear();\n  }\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n\n\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    }.bind(this));\n  }\n\n}\n\nexport default TileCache;","map":{"version":3,"names":["LRUCache","fromKey","getKey","TileCache","clear","getCount","pop","release","expireCache","usedTiles","canExpireCache","tile","peekLast","pruneExceptNewestZ","key","peekFirstKey","tileCoord","z","forEach","remove","bind"],"sources":["D:/Work/Learning/demo/node_modules/ol/TileCache.js"],"sourcesContent":["/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(\n      function (tile) {\n        if (tile.tileCoord[0] !== z) {\n          this.remove(getKey(tile.tileCoord));\n          tile.release();\n        }\n      }.bind(this)\n    );\n  }\n}\n\nexport default TileCache;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,QAAP,MAAqB,uBAArB;AACA,SAAQC,OAAR,EAAiBC,MAAjB,QAA8B,gBAA9B;;AAEA,MAAMC,SAAN,SAAwBH,QAAxB,CAAiC;EAC/BI,KAAK,GAAG;IACN,OAAO,KAAKC,QAAL,KAAkB,CAAzB,EAA4B;MAC1B,KAAKC,GAAL,GAAWC,OAAX;IACD;;IACD,MAAMH,KAAN;EACD;EAED;AACF;AACA;;;EACEI,WAAW,CAACC,SAAD,EAAY;IACrB,OAAO,KAAKC,cAAL,EAAP,EAA8B;MAC5B,MAAMC,IAAI,GAAG,KAAKC,QAAL,EAAb;;MACA,IAAID,IAAI,CAACT,MAAL,MAAiBO,SAArB,EAAgC;QAC9B;MACD,CAFD,MAEO;QACL,KAAKH,GAAL,GAAWC,OAAX;MACD;IACF;EACF;EAED;AACF;AACA;;;EACEM,kBAAkB,GAAG;IACnB,IAAI,KAAKR,QAAL,OAAoB,CAAxB,EAA2B;MACzB;IACD;;IACD,MAAMS,GAAG,GAAG,KAAKC,YAAL,EAAZ;IACA,MAAMC,SAAS,GAAGf,OAAO,CAACa,GAAD,CAAzB;IACA,MAAMG,CAAC,GAAGD,SAAS,CAAC,CAAD,CAAnB;IACA,KAAKE,OAAL,CACE,UAAUP,IAAV,EAAgB;MACd,IAAIA,IAAI,CAACK,SAAL,CAAe,CAAf,MAAsBC,CAA1B,EAA6B;QAC3B,KAAKE,MAAL,CAAYjB,MAAM,CAACS,IAAI,CAACK,SAAN,CAAlB;QACAL,IAAI,CAACJ,OAAL;MACD;IACF,CALD,CAKEa,IALF,CAKO,IALP,CADF;EAQD;;AAxC8B;;AA2CjC,eAAejB,SAAf"},"metadata":{},"sourceType":"module"}