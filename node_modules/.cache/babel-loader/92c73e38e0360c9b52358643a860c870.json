{"ast":null,"code":"/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\n\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {\n  simplifiedFlatCoordinates = simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n\n  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  const n = (end - offset) / stride;\n\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n\n\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n\n  const stack = [offset, end - stride];\n  let index = 0;\n\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];\n    }\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1]; // copy first point\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  } // snap the first coordinate (P1)\n\n\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride; // add the first coordinate to the output\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n\n  let x2, y2;\n\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride; // skip P3 if it is equal to P2\n\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    } // calculate the delta between P1 and P2\n\n\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1; // calculate the delta between P3 and P1\n\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n\n\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  } // add the last point (P2)\n\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}","map":{"version":3,"names":["squaredDistance","squaredSegmentDistance","simplifyLineString","flatCoordinates","offset","end","stride","squaredTolerance","highQuality","simplifiedFlatCoordinates","undefined","radialDistance","length","douglasPeucker","simplifiedOffset","n","markers","Array","stack","index","last","pop","first","maxSquaredDistance","x1","y1","x2","y2","i","x","y","push","douglasPeuckerArray","ends","simplifiedEnds","ii","douglasPeuckerMultiArray","endss","simplifiedEndss","snap","value","tolerance","Math","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray"],"sources":["D:/Work/Learning/demo/node_modules/ol/geom/flat/simplify.js"],"sourcesContent":["/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}