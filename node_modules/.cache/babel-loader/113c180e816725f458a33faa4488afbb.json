{"ast":null,"code":"/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport { abstract } from '../util.js';\nimport { assert } from '../asserts.js';\nimport { equivalent } from '../proj.js';\nimport { getKeyZXY, withinExtentAndZ } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection, wrapX } from '../tilegrid.js';\nimport { scale as scaleSize, toSize } from '../size.js';\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\n\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate\n    });\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    this.on;\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n\n    this.once;\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n\n    this.un;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     */\n\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n    const tileSize = [256, 256];\n\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n\n\n    this.tileCache = new TileCache(options.cacheSize || 0);\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n\n    this.tmpSize = [0, 0];\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.key_ = options.key || '';\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate\n    };\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n  /**\n   * @return {boolean} Can expire cache.\n   */\n\n\n  canExpireCache() {\n    return this.tileCache.canExpireCache();\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n\n\n  forEachLoadedTile(projection, z, tileRange, callback) {\n    const tileCache = this.getTileCacheForProjection(projection);\n\n    if (!tileCache) {\n      return false;\n    }\n\n    let covered = true;\n    let tile, tileCoordKey, loaded;\n\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile =\n          /** @type {!import(\"../Tile.js\").default} */\n          tileCache.get(tileCoordKey);\n          loaded = tile.getState() === TileState.LOADED;\n\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n\n    return covered;\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n\n\n  getGutterForProjection(projection) {\n    return 0;\n  }\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n\n\n  getKey() {\n    return this.key_;\n  }\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n\n\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n\n\n  getOpaque(projection) {\n    return this.opaque_;\n  }\n  /**\n   * @return {Array<number>|null} Resolutions.\n   */\n\n\n  getResolutions() {\n    if (!this.tileGrid) {\n      return null;\n    }\n\n    return this.tileGrid.getResolutions();\n  }\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n\n\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n\n\n  getTileGrid() {\n    return this.tileGrid;\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n\n\n  getTileCacheForProjection(projection) {\n    const sourceProjection = this.getProjection();\n    assert(sourceProjection === null || equivalent(sourceProjection, projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n    );\n    return this.tileCache;\n  }\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n\n\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  }\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n\n\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    projection = projection !== undefined ? projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n\n\n  clear() {\n    this.tileCache.clear();\n  }\n\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  updateCacheSize(tileCount, projection) {\n    const tileCache = this.getTileCacheForProjection(projection);\n\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  }\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  useTile(z, x, y, projection) {}\n\n}\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\n\n\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n\n    this.tile = tile;\n  }\n\n}\nexport default TileSource;","map":{"version":3,"names":["Event","Source","TileCache","TileState","abstract","assert","equivalent","getKeyZXY","withinExtentAndZ","getForProjection","getTileGridForProjection","wrapX","scale","scaleSize","toSize","TileSource","constructor","options","attributions","attributionsCollapsible","projection","state","interpolate","on","once","un","opaque_","opaque","undefined","tilePixelRatio_","tilePixelRatio","tileGrid","tileSize","getTileSize","getMinZoom","tileCache","cacheSize","tmpSize","key_","key","tileOptions","transition","zDirection","canExpireCache","expireCache","usedTiles","getTileCacheForProjection","forEachLoadedTile","z","tileRange","callback","covered","tile","tileCoordKey","loaded","x","minX","maxX","y","minY","maxY","containsKey","get","getState","LOADED","getGutterForProjection","getKey","setKey","changed","getOpaque","getResolutions","getTile","pixelRatio","getTileGrid","sourceProjection","getProjection","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","tileCoord","getWrapX","isGlobal","clear","refresh","updateCacheSize","tileCount","highWaterMark","useTile","TileSourceEvent","type"],"sources":["D:/Work/Learning/demo/node_modules/ol/source/Tile.js"],"sourcesContent":["/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {equivalent} from '../proj.js';\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    this.tileCache = new TileCache(options.cacheSize || 0);\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || '';\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.tileCache.canExpireCache();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  forEachLoadedTile(projection, z, tileRange, callback) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n\n    let covered = true;\n    let tile, tileCoordKey, loaded;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */ (\n            tileCache.get(tileCoordKey)\n          );\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    return this.opaque_;\n  }\n\n  /**\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions() {\n    if (!this.tileGrid) {\n      return null;\n    }\n    return this.tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  getTileCacheForProjection(projection) {\n    const sourceProjection = this.getProjection();\n    assert(\n      sourceProjection === null || equivalent(sourceProjection, projection),\n      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n    );\n    return this.tileCache;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    projection = projection !== undefined ? projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n  }\n\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  useTile(z, x, y, projection) {}\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}