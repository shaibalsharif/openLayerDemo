{"ast":null,"code":"/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { ceil, clamp, floor } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { intersectsLinearRing } from '../geom/flat/intersectsextent.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\n\nconst tmpTileCoord = [0, 0, 0];\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\n\nconst DECIMALS = 5;\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\n\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n\n    this.resolutions_ = options.resolutions;\n    assert(isSorted(this.resolutions_, function (a, b) {\n      return b - a;\n    }, true), 17); // `resolutions` must be sorted in descending order\n    // check if we've got a consistent zoom factor and origin\n\n    let zoomFactor;\n\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n\n    this.zoomFactor_ = zoomFactor;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.maxZoom = this.resolutions_.length - 1;\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n\n    this.origins_ = null;\n\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n\n    this.tileSizes_ = null;\n\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n\n\n    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n    assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.extent_ = extent !== undefined ? extent : null;\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n\n    this.fullTileRanges_ = null;\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n\n    this.tmpSize_ = [0, 0];\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        const tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n\n\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n\n\n  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n      }\n\n      if (callback(z, tileRange)) {\n        return true;\n      }\n\n      --z;\n    }\n\n    return false;\n  }\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n\n\n  getExtent() {\n    return this.extent_;\n  }\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n\n\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n\n\n  getMinZoom() {\n    return this.minZoom;\n  }\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n\n\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  }\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n\n\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n\n\n  getResolutions() {\n    return this.resolutions_;\n  }\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n\n\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, tempTileRange);\n      }\n\n      const tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);\n      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);\n    }\n\n    return null;\n  }\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n\n\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n\n\n  getTileRangeExtent(z, tileRange, tempExtent) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n\n\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    const tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n    const minX = tileCoord[1];\n    const minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n    return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], tempTileRange);\n  }\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n\n\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];\n  }\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n\n\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n\n\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n  }\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n\n\n  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    let tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n\n\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n\n\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n  }\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n\n\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n\n\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  }\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n   */\n\n\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  }\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n\n\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n\n\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return intersectsLinearRing(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));\n  }\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n\n\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n\n    this.fullTileRanges_ = fullTileRanges;\n  }\n\n}\n\nexport default TileGrid;","map":{"version":3,"names":["TileRange","createOrUpdate","createOrUpdateTileRange","DEFAULT_TILE_SIZE","assert","ceil","clamp","floor","getTopLeft","createOrUpdateTileCoord","intersectsLinearRing","isSorted","linearFindNearest","toSize","tmpTileCoord","DECIMALS","TileGrid","constructor","options","minZoom","undefined","resolutions_","resolutions","a","b","zoomFactor","origins","i","ii","length","zoomFactor_","maxZoom","origin_","origin","origins_","extent","tileSizes_","tileSizes","tileSize_","tileSize","extent_","fullTileRanges_","tmpSize_","tmpExtent_","sizes","map","size","z","tileRange","Math","min","max","restrictedTileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","calculateTileRanges_","forEachTileCoord","zoom","callback","j","jj","forEachTileCoordParentTileRange","tileCoord","tempTileRange","tempExtent","x","y","tileCoordExtent","getTileCoordExtent","getExtent","getMaxZoom","getMinZoom","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","pow","getTileRangeExtent","resolution","getTileSize","getTileCoordForXYAndZ_","getTileCoordCenter","getTileCoordForCoordAndResolution","coordinate","opt_tileCoord","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","getTileCoordForCoordAndZ","getTileCoordResolution","getFullTileRange","opt_direction","tileCoordIntersectsViewport","viewport","fullTileRanges","Array"],"sources":["D:/Work/Learning/demo/node_modules/ol/tilegrid/TileGrid.js"],"sourcesContent":["/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {ceil, clamp, floor} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 5;\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        function (a, b) {\n          return b - a;\n        },\n        true\n      ),\n      17\n    ); // `resolutions` must be sorted in descending order\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      18\n    ); // Either `origin` or `origins` must be configured, never both\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n        ? DEFAULT_TILE_SIZE\n        : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      22\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1)\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    tempTileRange,\n    tempExtent\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          tempTileRange\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          tempTileRange\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        tempExtent || this.tmpExtent_\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        tempTileRange\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        tempTileRange\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getTileRangeExtent(z, tileRange, tempExtent) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    const tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n    const minX = tileCoord[1];\n    const minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n    return createOrUpdateTileRange(\n      minX,\n      tileCoord[1],\n      minY,\n      tileCoord[2],\n      tempTileRange\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return intersectsLinearRing(\n      viewport,\n      0,\n      viewport.length,\n      2,\n      this.getTileCoordExtent(tileCoord)\n    );\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}