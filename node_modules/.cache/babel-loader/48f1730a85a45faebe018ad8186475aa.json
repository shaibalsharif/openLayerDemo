{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\n\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\n\n\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\n\nexport function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values\n\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [minResolution] Minimum resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\nexport function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values\n\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\n\nexport function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"names":["clamp","getHeight","getWidth","linearFindNearest","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","Math","min","max","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","smooth","undefined","direction","size","isMoving","length","cappedMaxRes","capped","z","floor","createSnapToPower","power","tolerance","minZoomLevel","ceil","offset","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution"],"sources":["D:/Work/Learning/demo/node_modules/ol/resolutionconstraint.js"],"sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport {clamp} from './math.js';\nimport {getHeight, getWidth} from './extent.js';\nimport {linearFindNearest} from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(\n  resolution,\n  maxExtent,\n  viewportSize,\n  showFullExtent\n) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n\n  result *=\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n    1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /=\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n        ratio +\n      1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(\n  resolutions,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [minResolution] Minimum resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(\n  power,\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance\n        );\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(\n          Math.log(maxResolution / capped) / Math.log(power) + offset\n        );\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(\n          resolution,\n          cappedMaxRes,\n          minResolution\n        );\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}