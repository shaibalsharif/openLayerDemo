{"ast":null,"code":"/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport { VOID } from '../functions.js';\nimport { clear } from '../obj.js';\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\n\nclass Target extends Disposable {\n  /**\n   * @param {*} [target] Default event target for dispatched events.\n   */\n  constructor(target) {\n    super();\n    /**\n     * @private\n     * @type {*}\n     */\n\n    this.eventTarget_ = target;\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n\n    this.pendingRemovals_ = null;\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n\n    this.dispatching_ = null;\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n\n    this.listeners_ = null;\n  }\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n\n\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n\n    if (!listenersForType.includes(listener)) {\n      listenersForType.push(listener);\n    }\n  }\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n\n\n  dispatchEvent(event) {\n    const isString = typeof event === 'string';\n    const type = isString ? event : event.type;\n    const listeners = this.listeners_ && this.listeners_[type];\n\n    if (!listeners) {\n      return;\n    }\n\n    const evt = isString ? new Event(event) :\n    /** @type {Event} */\n    event;\n\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\n    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});\n\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n\n    ++dispatching[type];\n    let propagate;\n\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if ('handleEvent' in listeners[i]) {\n        propagate =\n        /** @type {import(\"../events.js\").ListenerObject} */\n        listeners[i].handleEvent(evt);\n      } else {\n        propagate =\n        /** @type {import(\"../events.js\").ListenerFunction} */\n        listeners[i].call(this, evt);\n      }\n\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n\n    if (--dispatching[type] === 0) {\n      let pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n\n      delete dispatching[type];\n    }\n\n    return propagate;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n\n\n  getListeners(type) {\n    return this.listeners_ && this.listeners_[type] || undefined;\n  }\n  /**\n   * @param {string} [type] Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n\n\n  hasListener(type) {\n    if (!this.listeners_) {\n      return false;\n    }\n\n    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n  }\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n\n\n  removeEventListener(type, listener) {\n    const listeners = this.listeners_ && this.listeners_[type];\n\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n\n      if (index !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexport default Target;","map":{"version":3,"names":["Disposable","Event","VOID","clear","Target","constructor","target","eventTarget_","pendingRemovals_","dispatching_","listeners_","addEventListener","type","listener","listeners","listenersForType","includes","push","dispatchEvent","event","isString","evt","dispatching","pendingRemovals","propagate","i","ii","length","handleEvent","call","propagationStopped","pr","removeEventListener","disposeInternal","getListeners","undefined","hasListener","Object","keys","index","indexOf","splice"],"sources":["D:/Work/Learning/demo/node_modules/ol/events/Target.js"],"sourcesContent":["/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport {VOID} from '../functions.js';\nimport {clear} from '../obj.js';\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nclass Target extends Disposable {\n  /**\n   * @param {*} [target] Default event target for dispatched events.\n   */\n  constructor(target) {\n    super();\n\n    /**\n     * @private\n     * @type {*}\n     */\n    this.eventTarget_ = target;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.pendingRemovals_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.dispatching_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n    this.listeners_ = null;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n    if (!listenersForType.includes(listener)) {\n      listenersForType.push(listener);\n    }\n  }\n\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n  dispatchEvent(event) {\n    const isString = typeof event === 'string';\n    const type = isString ? event : event.type;\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\n    const pendingRemovals =\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n    ++dispatching[type];\n    let propagate;\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if ('handleEvent' in listeners[i]) {\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\n          listeners[i]\n        ).handleEvent(evt);\n      } else {\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\n          listeners[i]\n        ).call(this, evt);\n      }\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    if (--dispatching[type] === 0) {\n      let pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n      delete dispatching[type];\n    }\n    return propagate;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n  getListeners(type) {\n    return (this.listeners_ && this.listeners_[type]) || undefined;\n  }\n\n  /**\n   * @param {string} [type] Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  hasListener(type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return type\n      ? type in this.listeners_\n      : Object.keys(this.listeners_).length > 0;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default Target;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}