{"ast":null,"code":"/**\n * @module ol/geom/flat/interiorpoint\n */\nimport { linearRingsContainsXY } from './contains.js';\nimport { numberSafeCompareFunction } from '../../array.js';\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\n\nexport function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n\n  const intersections = []; // Calculate intersections with the horizontal line\n\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n\n      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {\n        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n  } // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n\n\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(numberSafeCompareFunction);\n  x1 = intersections[0];\n\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n\n    x1 = x2;\n  }\n\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  } else {\n    return [pointX, y, maxSegmentLength];\n  }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\n\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n  let interiorPoints = [];\n\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n    offset = ends[ends.length - 1];\n  }\n\n  return interiorPoints;\n}","map":{"version":3,"names":["linearRingsContainsXY","numberSafeCompareFunction","getInteriorPointOfArray","flatCoordinates","offset","ends","stride","flatCenters","flatCentersOffset","dest","i","ii","x","x1","x2","y1","y2","y","intersections","r","rr","length","end","push","pointX","NaN","maxSegmentLength","Infinity","sort","segmentLength","Math","abs","isNaN","getInteriorPointsOfMultiArray","endss","interiorPoints"],"sources":["D:/Work/Learning/demo/node_modules/ol/geom/flat/interiorpoint.js"],"sourcesContent":["/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {linearRingsContainsXY} from './contains.js';\nimport {numberSafeCompareFunction} from '../../array.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  dest\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(numberSafeCompareFunction);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  } else {\n    return [pointX, y, maxSegmentLength];\n  }\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters\n) {\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}